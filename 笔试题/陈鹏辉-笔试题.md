# 前端开发知识点
## HTML&CSS：
	对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
	HTML5、CSS3、Flexbox
#### 对web标准的理解:
web标准指的是将网页页面的结构、表现和行为各自独立实现，比如我们给页面增加html标签，将html标签用到的样式单独放在一个css文件中并引入到html页面上，用javascript操作dom和bom并将代码单独放在一个js
文件中实现行为的独立实现

#### 浏览器内核差异:
浏览器内核的意思是指渲染网页内容，将网页内容代码转化成你看得见的页面，由于不同浏览器采用的内核对网页内容的支持有所不同，所以导致部分代码需要处理对不同浏览器的兼容
常见的浏览器内核有：
- Trident内核(window)--IE 浏览器使用的内核
- WebKit内核（NB 的内核，跨平台）
Webkit内核是苹果公司自己的内核，也是苹果Safari浏览器使用的内核。Webkit引擎包含WebCore排版引擎和JavascriptCore解析引擎，均从KDE的KHTML引擎衍生而来，基于GPL开源。Google Chrome使用了Webkit内核，在脚本解析上Chrome使用了自家研发的V8引擎。
- Gecko内核是Firefox采用的内核，开始于Netscape6。Gecko的特点是代码完全公开，可开发程度很高。
Gecko内核也是一个跨平台的内核。
## JavaScript：
    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
	DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

## 其他：
    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力

# CSS类
## 假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应。
请写出五到七种方案，并说出各种方案的优缺点和兼容性

## 左侧菜单栏占300px，右侧内容可以根据浏览器自适应。根据此要求，编写html css代码

## CSS选择器又哪些？有哪些新特性？有哪些伪类？
#### css选择器
- id选择器
- 类名选择器
- 标签选择器
- 派生选择器 div span{ color: red;}
- 子级选择器 ul>li{background-color: red;}
- 分组选择器 div,p,ul{background-color: red;}
- 相邻兄弟选择器 p+p{color: red;}
- 属性选择器 [title=珠峰培训]{text-decoration: underline   }
- 伪类选择器 p:hover{color: blue;}input:focus{outline: 1px solid red;}
#### 伪类
- 选择所有未被访问的链接的状态
a:link{color:black}
- 鼠标经过的时候的状态 
a:hover{color: blue;}
- 鼠标点击时的状态 鼠标一旦释放样式就消失
a:active{color: red;}
- 鼠标点击后的效果
a:visited{ color: pink;}
- 父元素的第一个子元素节点
ul:first-child
- 选择获得焦点的 input 元素
input:focus
- 在每个p元素的内容之前插入内容
p:before
- 在每个p元素的内容之后插入内容
p:after
## 清除浮动的几种方式，优缺点
如果一个父盒子中有一个子盒子，并且父盒子没有设置高，子盒子在父盒子中进行了浮动，那么将来父盒子的高度为0.由于父盒子的高度为0，
下面的元素会自动补位，所以这个时候要进行浮动的清除。
#### 方式一:使用overflow属性来清除浮动
先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响.
注意：一般情况下也不会使用这种方式，因为overflow:hidden有一个特点，离开了这个元素所在的区域以后会被隐藏（overflow:hidden会将超出的部分隐藏起来）.
#### 方式二:使用额外标签(clear:both)法
在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响.
a.内部标签：会将这个浮动盒子的父盒子高度重新撑开.
b.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子.
注意：一般情况下不会使用这一种方式来清除浮动。因为这种清除浮动的方式会增加页面的标签，造成结构的混乱.
#### 方法三:使用伪元素来清除浮动(after意思:后来,以后)
````
.clearfix:after{<br>
　　centent:"";//设置内容为空<br>
　　height:0;//高度为0<br>
　　line-height:0;//行高为0<br>
　　display:block;//将文本转为块级元素<br>
　　visibility:hidden;//将元素隐藏<br>
　　clear:both//清除浮动<br>
}<br>
.clearfix{<br>
　　zoom:1;为了兼容IE<br>
}
````
#### 方法四:使用双伪元素清除浮动
````
.clearfix:before,.clearfix:after {
    content: "";                 
    display: block;
    clear: both;
}
.clearfix {
    zoom: 1;
}
````
#### 方法五:给父元素定高
#### 方法六:父元素浮动
当父元素浮动的时候，无需为子元素的浮动清除浮动,布局时经常用到
## 图片如何实现垂直剧中的
这种方法是要知道高度才可以使用，代码如下：
1)利用高==行高实现图片垂直居中
```
<div style="text-align: center; width: 500px;height:200px; line-height:200px; border: green solid 1px;">
   <img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="display: inline-block; vertical-align: middle;" />
</div>
```
2)利用table实现图片垂直居中
利用table的方法是利用了table的垂直居中属性，代码如下：

这里使用display: table;和display: table-cell;来模拟table，这种方法并不兼容IE6/IE7，IE67不支持display: table，如果你不需要支持IE67那就可以用

缺点：当你设置了display: table;可能会改变你的原有布局
````
<div style="text-align: center; width: 500px;height:200px; display: table;border: green solid 1px;">
	<span style="display: table-cell; vertical-align: middle; "><img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="display: inline-block;" /></span>
</div>
````
3)利用绝对定位实现图片垂直居中
如果已知图片的宽度和高度可以这样，代码如下：
````
<div style="width: 500px;height:200px; position: relative; border: green solid 1px;">
	<img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="width: 120px; height: 40px;position: absolute; left:50%; top: 50%; margin-left: -60px;margin-top: -20px;" />
</div>
````
4)移动端可以利用flex布局实现css图片垂直居中
移动端一般浏览器版本都比较高，所以可以大胆的使用flex布局
````
css代码：
<style type="text/css">
/*web前端开发http://www.51xuediannao.com/*/
        .ui-flex {
            display: -webkit-box !important;
            display: -webkit-flex !important;
            display: -ms-flexbox !important;
            display: flex !important;
            -webkit-flex-wrap: wrap;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap
        }

        .ui-flex, .ui-flex *, .ui-flex :after, .ui-flex :before {
            box-sizing: border-box
        }

        .ui-flex.justify-center {
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center
        }
        .ui-flex.center {
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center;
            -webkit-box-align: center;
            -webkit-align-items: center;
            -ms-flex-align: center;
            align-items: center
        }
    </style>
html代码：
<div class="ui-flex justify-center center" style="border: green solid 1px; width: 500px; height: 200px;">
    <div class="cell">
	<img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="" />
    </div>
</div>
````
## css hack你知道哪些？
#### css hack概念
由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!
#### CSS hack的原理
由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。
#### CSS hack分类
CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。
> - 属性前缀法(即类内部Hack)：例如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。
> - 选择器前缀法(即选择器Hack)：例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。
> - IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <!--[if IE]>IE浏览器显示的内容 <![endif]-->，针对IE6及以下版本： <!--[if lt IE 6]>只在IE6-显示的内容 <![endif]-->。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。
## 谈谈你对CSS盒模型的认识
- 标准模型和IE模型的区别?
> IE盒子模型中盒子中宽度或者高度包括边界和内边距和内容width/height=border+padding+content，而标准盒模型中宽度或者高度width/height就是content的宽度

- CSS是如何设置这两种模型?
> 盒子模型是用来描述一个元素内容的宽高，内外边距和边框样式的
盒模型由宽度width、高度height、内边距padding、边框border和外边距margin组成

- JS如何设置和获取盒模型对应的宽和高?
>- 设置宽度 curEle.style.width
curEle.style.height
>- 获取宽度 window.getComputedStyle(curEle, null)['width']
curEle.currentStyle['width']
>- 获取宽度 curEle.clientWidth、clientHeight
- 什么是优雅降级和渐进增强?
> 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
  　优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

## 谈谈你对BFC的了解
- 什么是BFC?
> BFC（Block formatting contexts），翻译过来就是块级格式化上下文，指的是一种上下文环境。官方给出的BFC解释是这样的，浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。
- 如何创建BFC?
> 根据W3C的定义：浮动元素，绝对定位元素，非块级盒子的块级容器（例如inline-blocks，table-cells，and table-captions），以及overflow属性值不是“ visible”（visible是overflow的默认值）的块级盒子（视口除外），这些元素就会为他们的内容创建一个BFC。
  
- BFC使用场景?
> BFC的应用场景有：
清除元素之间的影响、清除内部浮动元素对父级元素的影响、创建自适应布局比如两列布局中间自适应


# JS类

## DOM事件
- DOM事件级别有哪些?
>- DOM0级事件:一是在标签内写onclick事件
二是在JS写onlicke=function(){}函数<br>
>- DOM2级事件:只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()
dom二级事件的参数第一个参数是事件名，第二个是事件处理函数，第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。
- 描述DOM事件捕获和冒泡的具体流程?
> 捕获阶段：根节点-->逐级传播-->事件源<br>
> 冒泡阶段：事件源-->逐级传播-->根节点

- `Event`对象的常见应用场景?
 >- type 事件类型
 >- target 事件源
 >- clientX 针对于窗口 X轴坐标
 >- clientY 针对于窗口 Y轴坐标
 > -pageX 针对于body X轴坐标
    console.log(e.pageX === e.clientX + document.body.scrollLeft);
 >- PageY 针对于body Y轴坐标
    console.log(e.pageY === e.clientY + document.body.scrollTop);
 >- e.preventDefault() 阻止默认行为
 >- e.stopPropagation() // 阻止冒泡传播
 >- offsetX 相对于元素的 X轴坐标
 >- offsetY 相对于元素的 Y轴坐标
 >- e.preventDefault(); // 阻止默认行为 行内阻止


- 事件委托是什么？
> 事件委托：利用事件默认会进行冒泡传播的机制 给最外层元素相关行为绑定事件，当里面元素相关行为触发的时候 也会触发最外层元素的行为 然后我们可以根据事件对象中的事件源做出相应的处理

- 事件冒泡,e.target和e.currentTarget的区别
>- 冒泡和捕获的区别是冒泡事件是先触发子元素事件，再触发父元素事件，这个是冒泡。捕获是先触发父元素事件，再触发子元素事件。简单的来说，冒泡的顺序是由内到外，捕获的顺序是由外到内
>- target和currenttarget的区别 target指的是事件的真正触发者，currenttarget指的是事件的监听者，当不存在冒泡或者捕获的情况下，通常两者指向的对象为同一个，但是如果存在冒泡或者捕获，
就会指向各自所产生的对象,即冒泡过程中，外层元素监听了事件源发出事件，此时外层元素的e.target是事件源，e.currenttarget是监听者外层元素
- 浏览器的兼容问题(js)

## JS原生
- JS中有哪些数据类型
>- 基本数据类型
number string, boolean,null,undefined
>- 引用数据类型
Object Array Math RegExp Date Function
- 什么是闭包？闭包作用？在工作中是如何应用的?
>- 函数执行都会形成一个私有作用域 保护里面私有变量不受外界干扰 这种保护机制叫闭包
>- 通过从内部返回一个子函数 在外部接受 从而达到 访问和 修改内部私有变量目的
>- 在工作中用于划分模块，开发api库，和函数式编程
- JS实现继承的几种方式?
>- 原型链继承
(基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。)
>- call继承(借用构造函数,基本思想：在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。)
>- 原型式继承(基本想法：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。)
>- 寄生式继承(基本思想：和原型式继承很像，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象的属性和方法，最后再像真正是它做了所有工作一样返回对象。)
>- 组合继承(将原型链和借用构造函数的技术组合在一块，从而发挥两者之长的一种继承模式。)
>- 寄生组合继承(通过借用构造函数来继承私有属性和方法，通过寄生继承的思想继承父类原型上的属性和方法，另外还可以增强子类的属性和方法)

- 创建对象的三种方式?
> var a={},var b=new Object(),通过实例化一个构造函数
- `new Person()`时发生了什么?
> 产生了一个Person实例,这个实例对象上Person的私有属性和方法直接放在实例对象上，还有Person的公有属性和方法放在实例对象的__proto__属性上
- 什么是深拷贝和浅拷贝？自己不用`JSON.parse`实现一个深拷贝的方法
  > 对于基本数据类型浅拷贝只是对值的拷贝,对于引用数据类型浅拷贝前后的对象都是指向同一个地址
  深拷贝是指拷贝后产生一个新的地址指向新的空间，和原来的只是内容一样，但是放的地方不一样
  ````
  function copy(old){
    var new;
    if(old instaceof Array){
        new = old.slice(0)
        return new
    }
    if(Object.Prototype.toString.call(old)==="[Object Object]"){
        new = old.constructor;
        for(var i in obj){
            if(obj.hasOwnProperty(i)){
               new[i]=old[i];
            }
        } 
        return new;
    }
    return old
  }
  ````
- 手工模拟完整的bind方法
```
Function.prototype.mybind=function(obj){
    var arg = arguments.slice(1)
    return function(e){
        this.call(obj,e,arg)
    }
}
curEle.onClick=fn.mybind(obj,1,2)
function fn(arg){
    
}
```
- 什么是节流和防抖？
- 上拉刷新和下拉加载的实现原理？
> 无论是下拉刷新还是上拉加载更多，原理都是在内容View（ListView、RecyclerView…）不能下拉或者上划时响应用户的触摸事件，在顶部或者底部显示一个刷新视图，在程序刷新操作完成后再隐藏掉。
- 写一个验证邮件的正则表达式
cph994@163.com
cph994@qq.com.cn
````
/^\w+@[0-9a-z]{2,8}(\.[a-z]{2,8}){1,2}$/
````
- 事件绑定和普通事件的区别（可以举例说明）
>普通添加事件
````
  var btn = document.getElementById("btn");
  btn.onclick = function(){
  	alert(1);
  }
````
> 事件绑定方式添加事件
````
var btn = document.getElementById("btn");
btn.addEventListener("click",function(){
	alert(1);
},false);
````
- javascript 模版引擎用过哪些？实现原理是什么？
> 实现原理
模板引擎，说的简单点，就是一个字符串中有几个变量待定
1.正则抠出要匹配的内容2.装入数组3.分辨js逻辑部分4.引擎函数5.把data扔进去
- 合并两个对象
- 动态向一个div中插入1000个div标签，如何实现？（考性能）
- html5新特性
- 严格模式和非严格模式的区别
- 对于js中浮点数计算会丢失精度的问题，你有什么解决思路？

## JQuery
- jquery.extend , jquery.fn.extend的区别
> jquery.extend是对jQuery对象的扩展，可以理解为静态方法，是全局的，不需要实例jQuery就可以使用。
> jquery.fn.extend 是在jquery原型对象上扩展方法和属性
- 谈一下jquery中的bind，live，delegate，on区别
- document.ready和document.load和$(function(){})有什么区别？
- $.data()和$('#aaa').data()各自作用是什么？有什么区别

## ES6
- 什么时候应该用箭头函数？什么时候不能用？
－ 请写出ES6中Array.isArray()的实现代码
- 如何在项目中解析处理es6和es7代码
- Promise常用方法，Promise.race的作用，then方法里reject和catch的区别

## 工程化
- 什么叫模块化？你用过哪些模块化解决方案？
- 什么叫组件化？你在工作中是如何实现组件化的？
- gulp和webpack的相同点和不同点?
- 什么是热加载?

## 框架
- 前端路由的实现原理
- `MVVM`框架解决了什么问题？带来了什么问题？
- 浏览器地址栏里面的'＃' 如何清楚？mode共有几个参数，参数有什么区别？
- vue中父组件如何给子组件传递值
- react的优缺点
- React组件中props和state有什么区别？
- 什么是JSX
- 说一下angular、vue、react的相同点和不同点?各适用于什么样的项目场景?
- React中不同组件传递数据的方式有哪些？至少说出三种
- 请描述React的组件加载生命周期函数以及`shouldComponentUpdate`方法的实际使用场景?

## HTTP
- HTTP报文的组成部分
- GET和POST的区别
- HTTP常见状态码
- 什么是Restful API?
- HTTPS和HTTP的区别是什么?
- 从在浏览器中输入URL到页面渲染出来都经过了什么过程？
- JSON和JSONP 区别是什么？JSONP的原理是？
- 用过那些跨域技术
- ajax的参数

## 前后端通信
- 什么是同源策略及限制?
- 前后端如何通信?
- 用原生JS模拟一下`jquery`的`ajax`方法
- 跨域通信的几种方式?

## 安全
- `CSRF`的原理以及如何防御
- `XSS`的原生和如何防御

## 渲染机制
- 什么是`DOCTYPE`及作用?标准模式和兼容模式有什么区别?
- 浏览器是如何渲染页面的?
- 什么是重排？什么时候会触发重排?
- 什么是重绘？什么时候会触发重绘?

## JS运行机制
- 如何理解JS的单线程
- 什么是`Event Loop`,请简述其过程

## 服务器
- 如何在web应用中在实现权限控制?
- Web服务器、应用服务器、Web容器、反向代理服务器的区别和联系?

## 错误处理
- 前端错误的分类?
- 程序出现bug了，你是如何调试的?
- 如何分类捕获不同的错误?
- 如何把生产环境的错误上报？

## 页面性能
- 前端性能优化的方法有哪些？至少说出10种以上
- 如何实现JS的异步加载? `async`和`defer`的区别是什么?

## 缓存
- Expires和Cache-Control是如何工作的？
- Last-Modified和Etag是如何工作的？
- 请描述`cookie`、`sessionStorage`和`localStorage`的区别

# 项目问题
- 介绍一下你的项目？这个项目有哪些模块？你负责哪些模块？
- 你在项目中的角色
- 你觉得在项目中做的最出彩的点有哪些？
- 遇到过哪些非常难以解决的问题？最终是如何解决的？
- 如果你是项目负责人，你会如何分配任务？如何保证按时完成？如何让成员够持续成长？

# 正常非技术问题
- 请你自我介绍一下你自己？
- 你觉得你个性上最大的优点是什么？
- 说说你最大的缺点？
- 你对加班的看法？
- 在五年的时间内，你的职业规划？
- 你朋友对你的评价？
- 你还有什么问题要问我的吗？
- 你的业余爱好是什么？
- 你为什么从上家公司离职?

# 故意挖坑的问题
- 你的直属上级和顶级上级对一件事情的意见不一致，你会听谁的意见？
- 如果部门开发的时候和你的主管发生了争吵，你会如何处理？
- 与上级意见不一致，你将怎么办？
- 你喜欢跟什么样的主管共事？
- 我们为什么要聘用你?
- 你没有工作经验如何能胜任这份工作？
- 你最崇拜的人是谁?
- 你有创业的想法吗？

## 代码运行结果，并解释
```javascript
if(!("a" in window)){
  var a = 1;
}
console.log(a);
```

```javascript
function MyObj(){
  this.p.pid++;
}
MyObj.prototype.p = {'pid':0}
MyObj.prototype.getNum = function(num){
  return this.p.pid+num;
}
var _obj1 = new MyObj();
var _obj2 = new MyObj();
console.log(_obj1.getNum(1)+_obj2.getNum(2))
```

```javascript
var func = (function(a){
  this.a = a;
  return function(a){
    a+=this.a;
    return a;
  }
})(function(a,b){
  return a;
}(1,2));
func(4);
```


```javascript
function Foo() {
 getName = function () { alert (1); };
 return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//请写出以下输出结果：
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```


```javascript
for(var i=0;i<10;i++){
       alert(i);
       break;
   }
   alert(i);

   for(var i=0;i<10;i++){
      continue;
      alert(i);
   }
   alert(i)
```

```javascript
function C1(name){
	if(name) this.name = name;
}
function C2(name){
this.name =name;
}
function C3(name){
 this.name = name ||'join';
}
C1.prototype.name='Tom';
C2.prototype.name='Tom';
C3.prototype.name='Tom';
alert(new C1().name)+(new C2().name)+(new C3().name);

```

```javascript
var a=1;
Var obj ={
   “name”:”tom”
}
function fn(){
   var a2 = a,
   obj2 = obj,
   a2 =a,
   obj2.name =”jack”
}
fn();
console.log(a);
console.log(obj);
```

每个人必须建立自己的github地址将答案，放到github上，并且将答案抄在纸上（加深记忆 防止粘贴），晚上之前必须`每个人`都交上来，大家不许互相讨论，可以采用google和百度等手段，
目的：校验自己的不足查缺补漏，学会自我查找问题，提升解决问题的能力。
