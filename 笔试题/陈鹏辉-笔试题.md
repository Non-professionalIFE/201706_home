# 前端开发知识点
## HTML&CSS：
	对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、
	HTML5、CSS3、Flexbox
#### 对web标准的理解:
web标准指的是将网页页面的结构、表现和行为各自独立实现，比如我们给页面增加html标签，将html标签用到的样式单独放在一个css文件中并引入到html页面上，用javascript操作dom和bom并将代码单独放在一个js
文件中实现行为的独立实现

#### 浏览器内核差异:
浏览器内核的意思是指渲染网页内容，将网页内容代码转化成你看得见的页面，由于不同浏览器采用的内核对网页内容的支持有所不同，所以导致部分代码需要处理对不同浏览器的兼容
常见的浏览器内核有：
- Trident内核(window)--IE 浏览器使用的内核
- WebKit内核（NB 的内核，跨平台）
Webkit内核是苹果公司自己的内核，也是苹果Safari浏览器使用的内核。Webkit引擎包含WebCore排版引擎和JavascriptCore解析引擎，均从KDE的KHTML引擎衍生而来，基于GPL开源。Google Chrome使用了Webkit内核，在脚本解析上Chrome使用了自家研发的V8引擎。
- Gecko内核是Firefox采用的内核，开始于Netscape6。Gecko的特点是代码完全公开，可开发程度很高。
Gecko内核也是一个跨平台的内核。
## JavaScript：
    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、
	DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs

## 其他：
    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力

# CSS类
## 假设高度已知，请写出三栏布局，其中左栏、右栏宽度各为300px，中间自适应。
请写出五到七种方案，并说出各种方案的优缺点和兼容性

## 左侧菜单栏占300px，右侧内容可以根据浏览器自适应。根据此要求，编写html css代码

## CSS选择器又哪些？有哪些新特性？有哪些伪类？
#### css选择器
- id选择器
- 类名选择器
- 标签选择器
- 派生选择器 div span{ color: red;}
- 子级选择器 ul>li{background-color: red;}
- 分组选择器 div,p,ul{background-color: red;}
- 相邻兄弟选择器 p+p{color: red;}
- 属性选择器 [title=珠峰培训]{text-decoration: underline   }
- 伪类选择器 p:hover{color: blue;}input:focus{outline: 1px solid red;}
#### 伪类
- 选择所有未被访问的链接的状态
a:link{color:black}
- 鼠标经过的时候的状态 
a:hover{color: blue;}
- 鼠标点击时的状态 鼠标一旦释放样式就消失
a:active{color: red;}
- 鼠标点击后的效果
a:visited{ color: pink;}
- 父元素的第一个子元素节点
ul:first-child
- 选择获得焦点的 input 元素
input:focus
- 在每个p元素的内容之前插入内容
p:before
- 在每个p元素的内容之后插入内容
p:after
## 清除浮动的几种方式，优缺点
如果一个父盒子中有一个子盒子，并且父盒子没有设置高，子盒子在父盒子中进行了浮动，那么将来父盒子的高度为0.由于父盒子的高度为0，
下面的元素会自动补位，所以这个时候要进行浮动的清除。
#### 方式一:使用overflow属性来清除浮动
先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响.
注意：一般情况下也不会使用这种方式，因为overflow:hidden有一个特点，离开了这个元素所在的区域以后会被隐藏（overflow:hidden会将超出的部分隐藏起来）.
#### 方式二:使用额外标签(clear:both)法
在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响.
a.内部标签：会将这个浮动盒子的父盒子高度重新撑开.
b.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子.
注意：一般情况下不会使用这一种方式来清除浮动。因为这种清除浮动的方式会增加页面的标签，造成结构的混乱.
#### 方法三:使用伪元素来清除浮动(after意思:后来,以后)
````
.clearfix:after{<br>
　　centent:"";//设置内容为空<br>
　　height:0;//高度为0<br>
　　line-height:0;//行高为0<br>
　　display:block;//将文本转为块级元素<br>
　　visibility:hidden;//将元素隐藏<br>
　　clear:both//清除浮动<br>
}<br>
.clearfix{<br>
　　zoom:1;为了兼容IE<br>
}
````
#### 方法四:使用双伪元素清除浮动
````
.clearfix:before,.clearfix:after {
    content: "";                 
    display: block;
    clear: both;
}
.clearfix {
    zoom: 1;
}
````
#### 方法五:给父元素定高
#### 方法六:父元素浮动
当父元素浮动的时候，无需为子元素的浮动清除浮动,布局时经常用到
## 图片如何实现垂直剧中的
这种方法是要知道高度才可以使用，代码如下：
1)利用高==行高实现图片垂直居中
```
<div style="text-align: center; width: 500px;height:200px; line-height:200px; border: green solid 1px;">
   <img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="display: inline-block; vertical-align: middle;" />
</div>
```
2)利用table实现图片垂直居中
利用table的方法是利用了table的垂直居中属性，代码如下：

这里使用display: table;和display: table-cell;来模拟table，这种方法并不兼容IE6/IE7，IE67不支持display: table，如果你不需要支持IE67那就可以用

缺点：当你设置了display: table;可能会改变你的原有布局
````
<div style="text-align: center; width: 500px;height:200px; display: table;border: green solid 1px;">
	<span style="display: table-cell; vertical-align: middle; "><img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="display: inline-block;" /></span>
</div>
````
3)利用绝对定位实现图片垂直居中
如果已知图片的宽度和高度可以这样，代码如下：
````
<div style="width: 500px;height:200px; position: relative; border: green solid 1px;">
	<img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="width: 120px; height: 40px;position: absolute; left:50%; top: 50%; margin-left: -60px;margin-top: -20px;" />
</div>
````
4)移动端可以利用flex布局实现css图片垂直居中
移动端一般浏览器版本都比较高，所以可以大胆的使用flex布局
````
css代码：
<style type="text/css">
/*web前端开发http://www.51xuediannao.com/*/
        .ui-flex {
            display: -webkit-box !important;
            display: -webkit-flex !important;
            display: -ms-flexbox !important;
            display: flex !important;
            -webkit-flex-wrap: wrap;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap
        }

        .ui-flex, .ui-flex *, .ui-flex :after, .ui-flex :before {
            box-sizing: border-box
        }

        .ui-flex.justify-center {
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center
        }
        .ui-flex.center {
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center;
            -webkit-box-align: center;
            -webkit-align-items: center;
            -ms-flex-align: center;
            align-items: center
        }
    </style>
html代码：
<div class="ui-flex justify-center center" style="border: green solid 1px; width: 500px; height: 200px;">
    <div class="cell">
	<img alt="" src="https://www.baidu.com/img/baidu_jgylogo3.gif" style="" />
    </div>
</div>
````
## css hack你知道哪些？
#### css hack概念
由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack!
#### CSS hack的原理
由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。
#### CSS hack分类
CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。
> - 属性前缀法(即类内部Hack)：例如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，IE6~IE10都认识"\9"，但firefox前述三个都不能认识。
> - 选择器前缀法(即选择器Hack)：例如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。
> - IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： <!--[if IE]>IE浏览器显示的内容 <![endif]-->，针对IE6及以下版本： <!--[if lt IE 6]>只在IE6-显示的内容 <![endif]-->。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。
## 谈谈你对CSS盒模型的认识
- 标准模型和IE模型的区别?
> IE盒子模型中盒子中宽度或者高度包括边界和内边距和内容width/height=border+padding+content，而标准盒模型中宽度或者高度width/height就是content的宽度

- CSS是如何设置这两种模型?
> 盒子模型是用来描述一个元素内容的宽高，内外边距和边框样式的
盒模型由宽度width、高度height、内边距padding、边框border和外边距margin组成

- JS如何设置和获取盒模型对应的宽和高?
>- 设置宽度 curEle.style.width
curEle.style.height
>- 获取宽度 window.getComputedStyle(curEle, null)['width']
curEle.currentStyle['width']
>- 获取宽度 curEle.clientWidth、clientHeight
- 什么是优雅降级和渐进增强?
> 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
  　优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

## 谈谈你对BFC的了解
- 什么是BFC?
> BFC（Block formatting contexts），翻译过来就是块级格式化上下文，指的是一种上下文环境。官方给出的BFC解释是这样的，浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。
- 如何创建BFC?
> 根据W3C的定义：浮动元素，绝对定位元素，非块级盒子的块级容器（例如inline-blocks，table-cells，and table-captions），以及overflow属性值不是“ visible”（visible是overflow的默认值）的块级盒子（视口除外），这些元素就会为他们的内容创建一个BFC。
  
- BFC使用场景?
> BFC的应用场景有：
清除元素之间的影响、清除内部浮动元素对父级元素的影响、创建自适应布局比如两列布局中间自适应


# JS类

## DOM事件
- DOM事件级别有哪些?
>- DOM0级事件:一是在标签内写onclick事件
二是在JS写onlicke=function(){}函数<br>
>- DOM2级事件:只有一个：监听方法，有两个方法用来添加和移除事件处理程序：addEventListener()和removeEventListener()
dom二级事件的参数第一个参数是事件名，第二个是事件处理函数，第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。
- 描述DOM事件捕获和冒泡的具体流程?
> 捕获阶段：根节点-->逐级传播-->事件源<br>
> 冒泡阶段：事件源-->逐级传播-->根节点

- `Event`对象的常见应用场景?
 >- type 事件类型
 >- target 事件源
 >- clientX 针对于窗口 X轴坐标
 >- clientY 针对于窗口 Y轴坐标
 > -pageX 针对于body X轴坐标
    console.log(e.pageX === e.clientX + document.body.scrollLeft);
 >- PageY 针对于body Y轴坐标
    console.log(e.pageY === e.clientY + document.body.scrollTop);
 >- e.preventDefault() 阻止默认行为
 >- e.stopPropagation() // 阻止冒泡传播
 >- offsetX 相对于元素的 X轴坐标
 >- offsetY 相对于元素的 Y轴坐标
 >- e.preventDefault(); // 阻止默认行为 行内阻止


- 事件委托是什么？
> 事件委托：利用事件默认会进行冒泡传播的机制 给最外层元素相关行为绑定事件，当里面元素相关行为触发的时候 也会触发最外层元素的行为 然后我们可以根据事件对象中的事件源做出相应的处理

- 事件冒泡,e.target和e.currentTarget的区别
>- 冒泡和捕获的区别是冒泡事件是先触发子元素事件，再触发父元素事件，这个是冒泡。捕获是先触发父元素事件，再触发子元素事件。简单的来说，冒泡的顺序是由内到外，捕获的顺序是由外到内
>- target和currenttarget的区别 target指的是事件的真正触发者，currenttarget指的是事件的监听者，当不存在冒泡或者捕获的情况下，通常两者指向的对象为同一个，但是如果存在冒泡或者捕获，
就会指向各自所产生的对象,即冒泡过程中，外层元素监听了事件源发出事件，此时外层元素的e.target是事件源，e.currenttarget是监听者外层元素
- 浏览器的兼容问题(js)

## JS原生
- JS中有哪些数据类型
>- 基本数据类型
number string, boolean,null,undefined
>- 引用数据类型
Object Array Math RegExp Date Function
- 什么是闭包？闭包作用？在工作中是如何应用的?
>- 函数执行都会形成一个私有作用域 保护里面私有变量不受外界干扰 这种保护机制叫闭包
>- 通过从内部返回一个子函数 在外部接受 从而达到 访问和 修改内部私有变量目的
>- 在工作中用于划分模块，开发api库，和函数式编程
- JS实现继承的几种方式?
>- 原型链继承
(基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。)
>- call继承(借用构造函数,基本思想：在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。)
>- 原型式继承(基本想法：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型。)
>- 寄生式继承(基本思想：和原型式继承很像，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象的属性和方法，最后再像真正是它做了所有工作一样返回对象。)
>- 组合继承(将原型链和借用构造函数的技术组合在一块，从而发挥两者之长的一种继承模式。)
>- 寄生组合继承(通过借用构造函数来继承私有属性和方法，通过寄生继承的思想继承父类原型上的属性和方法，另外还可以增强子类的属性和方法)

- 创建对象的三种方式?
> var a={},var b=new Object(),通过实例化一个构造函数
- `new Person()`时发生了什么?
> 产生了一个Person实例,这个实例对象上Person的私有属性和方法直接放在实例对象上，还有Person的公有属性和方法放在实例对象的__proto__属性上
- 什么是深拷贝和浅拷贝？自己不用`JSON.parse`实现一个深拷贝的方法
  > 对于基本数据类型浅拷贝只是对值的拷贝,对于引用数据类型浅拷贝前后的对象都是指向同一个地址
  深拷贝是指拷贝后产生一个新的地址指向新的空间，和原来的只是内容一样，但是放的地方不一样
  ````
  function copy(old){
    var new;
    if(old instaceof Array){
        new = old.slice(0)
        return new
    }
    if(Object.Prototype.toString.call(old)==="[Object Object]"){
        new = old.constructor;
        for(var i in obj){
            if(obj.hasOwnProperty(i)){
               new[i]=old[i];
            }
        } 
        return new;
    }
    return old
  }
  ````
- 手工模拟完整的bind方法
```
Function.prototype.mybind=function(obj){
    var arg = arguments.slice(1)
    return function(e){
        this.call(obj,e,arg)
    }
}
curEle.onClick=fn.mybind(obj,1,2)
function fn(arg){
    
}
```
- 什么是节流和防抖？
> 防抖(Debouncing)
  
  像防抖还是很容易想到的，大概意思就是延时处理，然后如果在这段延时内又触发了事件，则重新开始延时。
  
  看代码最直观啦。
  
  // 简单示例
  ````
  window.addEventListener('resize',function(e){
      var t;
      return function(){
          if(t) clearTimeout(t);
          t = setTimeout(function(){
              // do something...
          },500);
      }
  }());
  ````
- 上拉刷新和下拉加载的实现原理？
> 无论是下拉刷新还是上拉加载更多，原理都是在内容View（ListView、RecyclerView…）不能下拉或者上划时响应用户的触摸事件，在顶部或者底部显示一个刷新视图，在程序刷新操作完成后再隐藏掉。
- 写一个验证邮件的正则表达式
````
/^\w+@[0-9a-z]{2,8}(\.[a-z]{2,8}){1,2}$/
````
- 事件绑定和普通事件的区别（可以举例说明）
>普通添加事件
````
  var btn = document.getElementById("btn");
  btn.onclick = function(){
  	alert(1);
  }
````
> 事件绑定方式添加事件
````
var btn = document.getElementById("btn");
btn.addEventListener("click",function(){
	alert(1);
},false);
````
- javascript 模版引擎用过哪些？实现原理是什么？
> 实现原理
模板引擎，说的简单点，就是一个字符串中有几个变量待定
1.正则抠出要匹配的内容2.装入数组3.分辨js逻辑部分4.引擎函数5.把data扔进去
- 合并两个对象
> var obj = Object.assign(o1, o2, o3);
> JQuery,$.extend(obj1,obj2)

- 动态向一个div中插入1000个div标签，如何实现？（考性能）
> 可以创建文档碎片然后再插入到父容器中ducument.createDocumentFragment()
- html5新特性
> html5 增加了一些新特性
>- 1.语义化标签-
>- 2.媒介 音视频 audio video  object
>- 3.canvas 绘画 ECharts
>- 4.地理定位 Geolocation API
>- 5.本地存储 local Storage 二级缓存  （Cookies） 一种存储方案
>- 6.WebSocket 通讯协议
>- 7.表单控件
- 严格模式和非严格模式的区别
1. 不允许用with。
 2. 所有变量必须声明，赋值给未声明的变量报错，而不是隐匿创建全局变量。
 3. eval中的代码不能创建eval所在作用域下的变量、函数。而是为eval单独创建一个作用域，并在eval返回时丢弃。
 4. 函数中的特殊对象arguments是静态副本，而不像非严格模式那样，修改arguments或修改参数变量会相互影响。
 5. 删除configurable=false的属性时报错，而不是忽略。
 6. 对象字面量重复属性名报错。
 7. 禁止八进制字面量，如010（八进制的8）。
 8. 严格模式下eval、arguments变为关键字，不能用作变量名。
 9. 一般函数调用时（不是对象的方法调用，也不使用apply/call/bind等修改this）this指向null，而不是全局变量。
10. 试图修改不可写属性（writable=false），在不可扩展的对象上添加属性时报TypeError，而不是忽略。
11. arguments.caller,arguements.callee被禁用
- 对于js中浮点数计算会丢失精度的问题，你有什么解决思路？
> 解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）
```
(0.1*10 + 0.2*10) / 10 == 0.3
```



## JQuery
- jquery.extend , jquery.fn.extend的区别
> jquery.extend是对jQuery对象的扩展，可以理解为静态方法，是全局的，不需要实例jQuery就可以使用。
> jquery.fn.extend 是在jquery原型对象上扩展方法和属性
- 谈一下jquery中的bind，live，delegate，on区别
>- 1.bind 根据指定类型绑定事件 type data handel 其实内部调用的是on 只是少传递了一个 filter
````  
   bind: function( types, data, fn ) {
       return this.on( types, null, data, fn );
   }
````
>- 2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的
````
$("a").live("click",function(){alert("ok");});
````
>- 3.delegate(selector,[type],[data],fn) 指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数
````   
   $("#container").delegate("a","click",function(){alert("ok");})
   $("a").live("click",function(){alert("ok");});
````
>- 4.on 根据指定类型绑定事件 type filter data handel
>- 差别：.bind()是直接绑定在元素上.live()则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和.bind()的优势是支持动态数据。
.delegate()则是更精确的小范围使用事件代理，性能优于.live()
.on()则是最新的1.9版本整合了之前的三种方式的新事件绑定机制
- document.ready和document.load和$(function(){})有什么区别？
>- ready事件：
 ready事件在DOM结构绘制完成之后就绘执行。这样能确保就算有大量的媒体文件没加载出来，JS代码一样可以执行。
>- load事件：
  load事件必须等到网页中所有内容全部加载完毕之后才被执行。如果一个网页中有大量的图片的话，则就会出现这种情况：网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致load事件不能够即时被触发。
>- $(function(){})的执行是在DOM准备好之后执行。
- $.data()和$('#aaa').data()各自作用是什么？有什么区别
>- $.data()
存储任意数据到指定的元素 并且/或者 返回设置的值。
>- $('#aaa').data()
在匹配元素上存储任意相关数据 或 返回匹配的元素集合中的第一个元素的给定名称的数据存储的值。

## ES6
### 什么时候应该用箭头函数？什么时候不能用？
#### 1. 定义对象方法

JS 中对象方法的定义方式是在对象上定义一个指向函数的属性，当方法被调用的时候，方法内的 this 就会指向方法所属的对象。

###### 1.1 定义字面量方法

因为箭头函数的语法很简洁，可能不少同学会忍不住用它来定义字面量方法，比如下面的例子 JS Bin：

const calculator = {
    array: [1, 2, 3],
    sum: () => {
        console.log(this === window); // => true
        return this.array.reduce((result, item) => result + item);
    }
};

console.log(this === window); // => true

// Throws "TypeError: Cannot read property 'reduce' of undefined"
calculator.sum();
calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。

解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，修正后的代码如下 JS Bin：

const calculator = {
    array: [1, 2, 3],
    sum() {
        console.log(this === calculator); // => true
        return this.array.reduce((result, item) => result + item);
    }
};
calculator.sum(); // => 6
这样 calculator.sum 就变成了普通函数，执行时 this 就指向 calculator 对象，自然能得到正确的计算结果。

###### 1.2 定义原型方法

同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误，比如下面的例子 JS Bin：

function Cat(name) {
    this.name = name;
}

Cat.prototype.sayCatName = () => {
    console.log(this === window); // => true
    return this.name;
};

const cat = new Cat('Mew');
cat.sayCatName(); // => undefined
使用传统的函数表达式就能解决问题 JS Bin：

function Cat(name) {
    this.name = name;
}

Cat.prototype.sayCatName = function () {
    console.log(this === cat); // => true
    return this.name;
};

const cat = new Cat('Mew');
cat.sayCatName(); // => 'Mew'
sayCatName 变成普通函数之后，被调用时的执行上下文就会指向新创建的 cat 实例。

#### 2. 定义事件回调函数

this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。

但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来。比如在客户端编程中常见的 DOM 事件回调函数（event listenner）绑定，触发回调函数时 this 指向当前发生事件的 DOM 节点，而动态上下文这个时候就非常有用，比如下面这段代码试图使用箭头函数来作事件回调函数 JS Bin：

const button = document.getElementById('myButton');
button.addEventListener('click', () => {
    console.log(this === window); // => true
    this.innerHTML = 'Clicked button';
});
在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。

使用函数表达式就可以在运行时动态的改变 this，修正后的代码 JS Bin：

const button = document.getElementById('myButton');
button.addEventListener('click', function() {
    console.log(this === button); // => true
    this.innerHTML = 'Clicked button';
});
当用户单击按钮时，事件回调函数中的 this 实际指向 button，这样的 this.innerHTML = 'Clicked button' 就能按照预期修改按钮中的文字。

#### 3. 定义构造函数

构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。

换句话说，箭头构造函数的执行并没有任何意义，并且是有歧义的。比如，当我们运行下面的代码 JS Bin：

const Message = (text) => {
    this.text = text;
};
// Throws "TypeError: Message is not a constructor"
const helloMessage = new Message('Hello World!');
构造新的 Message 实例时，JS 引擎抛了错误，因为 Message 不是构造函数。在笔者看来，相比旧的 JS 引擎在出错时悄悄失败的设计，ES6 在出错时给出具体错误消息是非常不错的实践。可以通过使用函数表达式或者函数声明 来声明构造函数修复上面的例子 JS Bin：

const Message = function(text) {
    this.text = text;
};
const helloMessage = new Message('Hello World!');
console.log(helloMessage.text); // => 'Hello World!'
#### 4. 追求过短的代码

箭头函数允许你省略参数两边的括号、函数体的花括号、甚至 return 关键词，这对编写更简短的代码非常有帮助。这让我想起大学计算机老师给学生留过的有趣作业：看谁能使用 C 语言编写出最短的函数来计算字符串的长度，这对学习和探索新语言特性是个不错的法子。但是，在实际的软件工程中，代码写完之后会被很多工程师阅读，真正的 write once, read many times，在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，比如下面的例子 JS Bin：

const multiply = (a, b) => b === undefined ? b => a * b : a * b;
const double = multiply(2);
double(3);      // => 6
multiply(2, 3); // => 6
multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者使用普通的函数 JS Bin：

function multiply(a, b) {
    if (b === undefined) {
        return function (b) {
            return a * b;
        }
    }
    return a * b;
}

const double = multiply(2);
double(3); // => 6
multiply(2, 3); // => 6
为了让代码可读性更高，在简短和啰嗦之间把握好平衡是非常有必要的。

#### 5. 总结

箭头函数无疑是 ES6 带来的重大改进，在正确的场合使用箭头函数能让代码变的简洁、短小，但某些方面的优势在另外一些方面可能就变成了劣势，在需要动态上下文的场景中使用箭头函数你要格外的小心，这些场景包括：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。
### 请写出ES6中Array.isArray()的实现代码
````
Array.isArray=function(arg){
    return Object.prototype.toString.call(arg)==='[object Array]' 
}

````
- 如何在项目中解析处理es6和es7代码
可以使用babel，Babel是一个广泛使用的转码器，可以将ES6，ES7代码转为ES5代码，从而在现有环境执行
- Promise常用方法，Promise.race的作用，then方法里reject和catch的区别

>- 1 promise.then
所有的 promise 对象实例里都有一个then 方法，它是用来跟这个 promise 进行交互的。首先，then 方法会缺省调用 resolve() 函数:
````
new Promise(function(resolve, reject) {
     // Amock async action using setTimeout
     setTimeout(function(){ resolve(10); }, 3000);
})
.then(function(result) {
     console.log(result);
});
 
// From the console:
// 10
````
then 回调动作的触发时机是 promise 被执行完。我们还可以串联 then 方法执行回调操作：
````
new Promise(function(resolve, reject) {
     // Amock async action using setTimeout
     setTimeout(function(){ resolve(10); }, 3000);
})
.then(function(num) { console.log('first then:', num); return num * 2; })
.then(function(num) { console.log('second then:', num); return num * 2; })
.then(function(num) { console.log('last then: ',num);});
 
// From the console:
// first then: 10
// second then: 20
// lastthen:  40
````
你会发现，每次 then 调用都会以之前的 then 调用的返回值为参数。
如果一个 promise 已经执行完成，单then 被再次调用时，回调动作将会被再次执行。而如果这个 promise 里执行的是reject 回调函数，这是再调用 then 方法，回调函数将不会被执行。
>- promise.all
在我们的异步调用时经常有这样一种场景：我们需要同时调用多个异步操作，但希望只有等所有的操作都完成后，我们才去执行响应操作——这就是Promise.all 的作用。 Promise.all 方法可以接收多个 promise 作为参数，以数组的形式，当这些 promise 都成功执行完成后才调用回调函数。
````
Promise.all([promise1, promise2]).then(function(results){
     //Both promises resolved
})
.catch(function(error) {
     //One or more promises was rejected
});
````
一个很好的能演示 Promise.all 用法的例子是，执行多个 AJAX 操作(通过 fetch) 调用:
````
var request1 = fetch('/users.json');
var request2 = fetch('/articles.json');
 
Promise.all([request1, request2]).then(function(results) {
     // Both promises done!
});
````
一旦promise 里调用了reject函数，也就是执行被拒绝了，没有能够正常完成，情况会有些复杂。一旦promise 被拒绝，catch 方法会捕捉到首个被执行的reject函数：
```` 
var req1 = new Promise(function(resolve, reject){
     // Amock async action using setTimeout
     setTimeout(function(){ resolve('First!'); }, 4000);
});
var req2 = new Promise(function(resolve, reject){
     // Amock async action using setTimeout
     setTimeout(function(){ reject('Second!'); }, 3000);
});
Promise.all([req1, req2]).then(function(results){
     console.log('Then:', one);
}).catch(function(err) {
     console.log('Catch:', err);
});
 
// From the console:
// Catch:Second!
````
>- 3.promise.catch
catch 当一个 promise 被拒绝(reject)时,catch 方法会被执行：
````
new Promise(function(resolve,reject) {
     // A mock async action using setTimeout
     setTimeout(function() { reject('Done!'); },3000);
})
.then(function(e){ console.log('done', e); })
.catch(function(e){ console.log('catch: ', e); });
 
// From theconsole:
// 'catch:Done!'
````
通常我们在 reject 方法里处理执行失败的结果，而在catch 里执行异常结果：
reject(Error('Data could not be found'));
>- 4.promise.race
Promise.race 是一个有趣的函数——它不是等待所有的 promise 被resolve 或 reject，而是在所有的 promise 中只要有一个执行结束，它就会触发：
````
var req1 = newPromise(function(resolve, reject) {
     // A mock async action using setTimeout
     setTimeout(function() { resolve('First!'); },8000);
});
var req2 = newPromise(function(resolve, reject) {
     // A mock async action using setTimeout
     setTimeout(function() { resolve('Second!');}, 3000);
});
Promise.race([req1,req2]).then(function(one) {
     console.log('Then: ', one);
}).catch(function(one,two) {
     console.log('Catch: ', one);
});
````

## 工程化
- 什么叫模块化？你用过哪些模块化解决方案？
> 模块化是一种处理复杂系统分解为更好的可管理模块的方式。
模块化解决方案
>- 1.对象字面量表示法
  对象字面量可以认为是包含一组键值对的对象，每一对键和值由冒号分隔。对象字面量不需要使用new运算符进行实例化，在对象的外部也可以给对象添加属性和方法。
>- 2.Module模式
Module模式最初定义在传统的软件工程中，为类提供私有和公有封装的方法。在JavaScript中，并不能可以直接声明类，但我们可以使用闭包来封装私有的属性和方法，进而模拟类的概念，在JavaScript中实现Module模式。通过这种方式，我们就使得一个单独的对象拥有公有/私有方法和变量，从而屏蔽来自全局作用域的特殊部分，也就大大降低了变量声明之间和函数声明之间冲突的可能性。
>- 3.AMD模块
AMD全称是Asynchronous Module Definition，即异步模块加载机制。它诞生于使用XHR+eval的Dojo开发经验，其整体目标是提供模块化的JavaScript解决方案，避免未来的任何解决方案受到过去解决方案缺点的影响。AMD模块格式本身就是对定义模块的建议，其模块和依赖都可以进行异步加载，而且具有高度的灵活性，清除了代码和模块之间可能惯有的紧耦合。
关于AMD有两个非常重要的概念，那就是用于模块定义的define方法和用于处理依赖加载的require方法。

- 什么叫组件化？你在工作中是如何实现组件化的？
 > 组件是对逻辑的封装，不限于图形元素。即我们可以把if做成组件、把一个倒计时做成组件、把一段动画做成组件、把路由做成组件、把数据架构做成组件，而这些并不能称为控件
 组件具备单个可移植性，即“随加载随用”，不需要为其准备复杂的基础条件（如引入样式、引入框架等）
 在工作中使用类封装组件可以实现组件化，还有vue组件，react组件，angular组件
- gulp和webpack的相同点和不同点?
>- gulp是可以自动化执行任务的工具 在平时开发的流程里面,一定有一些任务需要手工重复得执行,只要你觉得有些动作是要重复去做的,就可以把这些动作创建成一个gulp任务,然后在特定的条件下自动执行. 比如在less源文件发生改变后自动编译成css文件
>- webpack是一款强大的模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理,优势如下:
   webpack 是以commonJS的形式来书写，但对AMD/CMD的支持也很全面,方便旧项目进行代码迁移
   能被模块化的不仅仅是JS,还包括各种资源文件
   开发便捷，能替代部分gulp的工作，比如打包、混淆压缩、图片转base64等
   扩展性强，插件机制完善，特别是支持React热插拔
- 什么是热加载?
>- 热更新就是当你在开发环境修改代码后，不用刷新整个页面即可看到修改后的效果。
如果你的项目中使用了webpack的话，你会很幸运，借助webpack-dev-server插件可以实现项目的热更新。

## 框架
- 前端路由的实现原理
>- hash
我们经常在 url 中看到 #，这个 # 有两种情况，一个是我们所谓的锚点，比如典型的回到顶部按钮原理、Github 上各个标题之间的跳转等，路由里的 # 不叫锚点，我们称之为 hash，大型框架的路由系统大多都是哈希实现的。
同样我们需要一个根据监听哈希变化触发的事件 —— hashchange 事件
我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。
这里我在 codepen 上模拟了一下原理: http://codepen.io/orangexc/pe...点击预览
hashchange 在低版本 IE 需要通过轮询监听 url 变化来实现，我们可以模拟如下
````
(function(window) {

  // 如果浏览器不支持原生实现的事件，则开始模拟，否则退出。
  if ( "onhashchange" in window.document.body ) { return; }

  var location = window.location,
  oldURL = location.href,
  oldHash = location.hash;

  // 每隔100ms检查hash是否发生变化
  setInterval(function() {
    var newURL = location.href,
    newHash = location.hash;

    // hash发生变化且全局注册有onhashchange方法（这个名字是为了和模拟的事件名保持统一）；
    if ( newHash != oldHash && typeof window.onhashchange === "function"  ) {
      // 执行方法
      window.onhashchange({
        type: "hashchange",
        oldURL: oldURL,
        newURL: newURL
      });

      oldURL = newURL;
      oldHash = newHash;
    }
  }, 100);
})(window);
````
- `MVVM`框架解决了什么问题？带来了什么问题？
>MVVM设计模式的优点 
>- 1.双向绑定技术，当Model变化时，View-Model会自动更新，View也会自动变化。很好做到数据的一致性，不用担心，在模块的这一块数据是这个值，在另一块就是另一个值了。所以 MVVM模式有些时候又被称作：model-view-binder模式。 
>- 2.View的功能进一步的强化，具有控制的部分功能，若想无限增强它的功能，甚至控制器的全部功几乎都可以迁移到各个View上（不过这样不可取，那样View干了不属于它职责范围的事情）。View可以像控制器一样具有自己的View-Model. 
>- 3.由于控制器的功能大都移动到View上处理，大大的对控制器进行了瘦身。不用再为看到庞大的控制器逻辑而发愁了。 
>- 4.可以对View或ViewController的数据处理部分抽象出来一个函数处理model。这样它们专职页面布局和页面跳转，它们必然更一步的简化。 
- 浏览器地址栏里面的'＃' 如何清楚？mode共有几个参数，参数有什么区别？
- vue中父组件如何给子组件传递值
> 父亲-> 儿子 默认组件是独立的相互不能引用数据，可以通过属性的方式传递给儿子
````
    let vm = new Vue({
        el:'#app',
        data:{money:100},//根实例数据都是对象，组件中都是函数
        template:'<child :m="money" o="美女"/>',
        components:{
            child:{
                //如果传递多个可以数组中写多个
                props:['m','o'],//这个m会挂载在儿子的实例上，相当于挂在了data上,父亲的数据儿子不能更改
                computed:{
                  b(){ return '大'+this.o} //this当前的是当前组件的实例
                },
                template:'<div>child {{m}} {{b}}</div>'
            }
        }
    })
````
- react的优缺点
> 优点：
>- 能够实现服务器端的渲染，便于搜索引擎优化。这一点要比Backbone, Angular 1.x和Ember早期强
>- 能够很好的和现有的代码结合。React只是MVC中的View层，对于其他的部分并没有硬性要求。意味着很多公司在选择用Angular全部重构和用React部分重构的时候，选择了React部分重构
>- 因为一切都是component，所以代码更加模块化，重用代码更容易
>- 学起来非常容易，几个小时就可以入门
>- 因为强调只从this.props和this.state生成HTML，
>- 比较高大上的优点，就是大家在大会上会说的优点：因为用了virtual dom，所以性能很好因为强调只从this.props和this.state生成HTML，所以非常的functional programming缺点：并不是一个完整的框架，基本都需要加上ReactRouter和Flux才能写大型应用

- React组件中props和state有什么区别？
>- props:props是一个组件的设置参数，可以在父控件中选择性设置。父组件对子控件的props进行赋值，并且props的值不可改变。一个子控件自身不能改变自己的 props。
>- state:当一个组件 mounts的时候，state如果设置有默认值的会被使用，并且state可能时刻的被改变。一个子控件自身可以管理自己的state，但是需要注意的是，无法管理其子控件的state。所以可以认为，state是子控件自身私有的。
>- 总结的来说，props是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中。然而 state代表的是子组件自身的内部状态。
- 什么是JSX
>- 1、JSX看起来像是XML的JavaScript语法扩展。React可以用来做简单的JSX语法转换。
>- 二、JSX使用
   1、HTML标签与React组件对比
   React可以渲染HTML标签（strings)或者React组件（classes）。
   要渲染HTML标签：只需在JSX里使用小写字母开头的标签名。例如：
   var myDivElement= <div className="foo"/>;
   React.render(myDivElement,document.body);
   要渲染React组件只需创建一个大写字母开头的本地变量：
   varMyComponent =React.createClass({/*...*/});
    varmyElement= <MyComponent someProperty={true}/>; React.render(myElement,document.body);
- 说一下angular、vue、react的相同点和不同点?各适用于什么样的项目场景?
#### React

React 和 Vue 有许多相似之处，它们都有：

使用 Virtual DOM
提供了响应式（Reactive）和组件化（Composable）的视图组件。
将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。
由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要指出 React 比 Vue 更好的地方，像是他们的生态系统和丰富的自定义渲染器。

React社区为我们准确进行平衡的考量提供了非常积极地帮助，特别感谢来自 React 团队的 Dan Abramov 。他非常慷慨的花费时间来贡献专业知识，帮助我们完善这篇文档，最后我们对最终结果都十分满意。

#### 性能简介

到目前为止，针对现实情况的测试中，Vue 的性能是优于 React 的。如果你对此表示怀疑，请继续阅读。我们会解释为什么会这样（并且会提供一个与 React 团队共同约定的比较基准）。

渲染性能

在渲染用户界面的时候，DOM 的操作成本是最高的，不幸的是没有库可以让这些原始操作变得更快。
我们能做到的最好效果就是：

Minimize the number of necessary DOM mutations. Both React and Vue use virtual DOM abstractions to accomplish this and both implementations work about equally well.
Add as little overhead (pure JavaScript computations) as possible on top of those DOM manipulations. This is an area where Vue and React differ.
The JavaScript overhead is directly related to the mechanisms of computing the necessary DOM operations. Both Vue and React utilizes Virtual DOM to achieve that, but Vue’s Virtual DOM implementation (a fork of snabbdom) is much lighter-weight and thus introduces less overhead than React’s.

Vue 和 React 也提供功能性组件，这些组件因为都是没有声明，没有实例化的，因此会花费更少的开销。当这些都用于关键性能的场景时，Vue 将会更快。为了证明这点，我们建立了一个简单的参照项目，它负责渲染 10,000 个列表项 100 次。我们鼓励你基于此去尝试运行一下。然而在实际上，由于浏览器和硬件的差异甚至 JavaScript 引擎的不同，结果都会相应有所不同。


更新性能

In React, when a component’s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root.

To avoid unnecessary re-renders of child components, you need to implementshouldComponentUpdate everywhere and use immutable data structures. In Vue, a component’s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render.

这意味着，未经优化的 Vue 相比未经优化的 React 要快的多。由于 Vue 改进过渲染性能，甚至全面优化过的 React 通常也会慢于开箱即用的 Vue。

开发中

显然，在生产环境中的性能是至关重要的，目前为止我们所具体讨论的便是针对此环境。但开发过程中的表现也不容小视。不错的是用 Vue 和 React 开发大多数应用的速度都是足够快的。

然而，假如你要开发一个对性能要求比较高的数据可视化或者动画的应用时，你需要了解到下面这点：在开发中，Vue 每秒最高处理 10 帧，而 React 每秒最高处理不到 1 帧。

Both Vue and React remain fast enough in development for most normal applications. However, when prototyping high frame-rate data visualizations or animations, we’ve seen cases of Vue handling 10 frames per second in development while React dropping to about 1 frame per second.

这是由于 React 有大量的检查机制，这会让它提供许多有用的警告和错误提示信息。我们同样认为这些是很重要的，但是我们在实现这些检查时，也更加密切地关注了性能方面。

#### HTML & CSS

在 React 中，它们都是 JavaScript 编写的，听起来这十分简单和优雅。然而不幸的事实是，JavaScript 内的 HTML 和 CSS 会产生很多痛点。在 Vue 中我们采用 Web 技术并在其上进行扩展。接下来将通过一些实例向你展示这意味的是什么。

JSX vs Templates

在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 Javascript 的一种语法糖。这有一个通过React社区审核过的例子：
````
render () {
let { items } = this.props
let children
if ( items.length > 0 ) {
children = (
<ul>
{items.map( item =>
<li key={item.id}>{item.name}</li>
)}
</ul>
)
} else {
children = <p>No items found.</p>
}
return (
<div className = ‘list-container’>
{children}
</div>
)
}
````
JSX 的渲染功能有下面这些优势：

你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。
工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的（比如，linting、类型检查、编辑器的自动完成）。
在 Vue 中，由于有时需要用这些功能，我们也提供了渲染功能 并且支持了 JSX。然而，对于大多数组件来说，渲染功能是不推荐使用了。

在这方面，我们提供的是更简单的模板：
````
<template>
<div class=“list-container”>
<ul v-if=“items.length”>
<li v-for=“item in items”>
{{ item.name }}
</li>
</ul>
<p v-else>No items found.</p>
</div>
</template>
````
优点如下：

在写模板的过程中，样式风格已定并涉及更少的功能实现。
模板总是会被声明的。
模板中任何 HTML 语法都是有效的。
阅读起来更贴合英语（比如，for each item in items）。
不需要高级版本的 JavaScript 语法，来增加可读性。
这样，不仅开发人员更容易编写代码，设计人员和开发人员也可以更容易的分析代码和贡献代码。

这还没有结束。Vue 拥抱 HTML，而不是用 JavaScript 去重塑它。在模板内，Vue 也允许你用预处理器比如 Pug（原名 Jade）。

div.list-container
ul(v-if=”items.length”)
li(v-for=”item in items”) {{ item.name }}
p(v-else) No items found.
CSS 的组件作用域

除非你把组件分布在多个文件上(例如 CSS Modules)，要不在 React 中作用域内的 CSS 就会产生警告。非常简单的 CSS 还可以工作，但是稍微复杂点的，比如悬停状态、媒体查询、伪类选择符等要么通过沉重的依赖来重做要么就直接不能用。

而 Vue 可以让你在每个单文件组件中完全访问 CSS。
````
<style scoped>
@media (min-width: 250px) {
.list-container:hover {
background: orange;
}
}
</style>
````
这个可选 scoped 属性会自动添加一个唯一的属性（比如 data-v-21e5b78）为组件内 CSS 指定作用域，编译的时候 .list-container:hover 会被编译成类似.list-container[data-v-21e5b78]:hover。

最后，就像 HTML 一样，你可以选择自己偏爱的 CSS 预处理器编写 CSS。这可以让你围绕设计为中心展开工作，而不是引入专门的库来增加你应用的体积和复杂度。

#### 规模

向上扩展

Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神（比如Flux、Redux），而这些状态管理模式甚至 Redux 本身也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式（Vuex），更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。

两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。

最后，Vue 提供了Vue-cli 脚手架，能让你非常容易地构建项目，包含了 Webpack,Browserify, 甚至 no build system。React 在这方面也提供了create-react-app，但是现在还存在一些局限性：

它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。
它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。
它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。
而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。如果阅读更多关于不同的设计理念。

向下扩展

React 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。

就像 Vue 向上扩展好比 React 一样，Vue 向下扩展后就类似于 jQuery。你只要把如下标签放到页面就可以运行：

<script src="https://unpkg.com/vue/dist/vue.js"></script>

然后你就可以编写 Vue 代码并应用到生产中，你只要用 min 版 Vue 文件替换掉就不用担心其他的性能问题。

由于起步阶段不需学 JSX，ES2015 以及构建系统，所以开发者只需不到一天的时间阅读指南就可以建立简单的应用程序。

#### 本地渲染

ReactNative 能使你用相同的组件模型编写有本地渲染能力的 APP（IOS 和 Android）。能同时跨多平台开发，对开发者是非常棒的。相应地，Vue 和 Weex 会进行官方合作，Weex 是阿里的跨平台用户界面开发框架，Weex 的 JavaScript 框架运行时用的就是 Vue。这意味着在 Weex 的帮助下，你使用 Vue 语法开发的组件不仅仅可以运行在浏览器端，还能被用于开发 IOS 和 Android 上的原生应用。

在现在，Weex 还在积极发展，成熟度也不能和 ReactNative 相抗衡。但是，Weex 的发展是由世界上最大的电子商务企业的需求在驱动，Vue 团队也会和 Weex 团队积极合作确保为开发者带来良好的开发体验。

#### MobX

Mobx 在 React 社区很流行，实际上在 Vue 也采用了几乎相同的反应系统。在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue，所以如果你习惯组合使用它们，那么选择 Vue 会更合理。

#### Angular 1

Vue 的一些语法和 Angular 的很相似（例如 v-if vs ng-if）。因为 Angular 是 Vue 早期开发的灵感来源。然而，Augular 中存在的许多问题，在 Vue 中已经得到解决。

#### 复杂性

在 API 与设计两方面上 Vue.js 都比 Angular 1 简单得多，因此你可以快速地掌握它的全部特性并投入开发。

#### 灵活性和模块化

Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 Angular 1 制定的规则，这让 Vue 能适用于各种项目。我们知道把决定权交给你是非常必要的。
这也就是为什么我们提供 Webpack template，让你可以用几分钟，去选择是否启用高级特性，比如热模块加载、linting、CSS 提取等等。

#### 数据绑定

Angular 1 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。

#### 指令与组件

在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元 —— 有自己的视图和数据逻辑。在 Angular 中两者有不少相混的地方。

#### 性能

Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。

在 Angular 1 中，当 watcher 越来越多时会变得越来越慢，因为作用域内的每一次变化，所有 watcher 都要重新计算。并且，如果一些 watcher 触发另一个更新，脏检查循环（digest cycle）可能要运行多次。Angular 用户常常要使用深奥的技术，以解决脏检查循环的问题。有时没有简单的办法来优化有大量 watcher 的作用域。

Vue 则根本没有这个问题，因为它使用基于依赖追踪的观察系统并且异步队列更新，所有的数据变化都是独立触发，除非它们之间有明确的依赖关系。

有意思的是，Angular 2 和 Vue 用相似的设计解决了一些 Angular 1 中存在的问题。

#### Angular 2

我们单独将 Augluar 2 作分类，因为它完全是一个全新的框架。例如：它具有优秀的组件系统，并且许多实现已经完全重写，API 也完全改变了。

#### TypeScript

Angular 1 面向的是较小的应用程序，Angular 2 已转移焦点，面向的是大型企业应用。在这一点上 TypeScript 经常会被引用，它对那些喜欢用 Java 或者 C# 等类型安全的语言的人是非常有用的。

Vue 也十分适合制作企业应用，你也可以通过使用官方类型或用户贡献的装饰器来支持 TypeScript，这完全是自由可选的。

#### 大小和性能

在性能方面，这两个框架都非常的快。但目前尚没有足够的数据用例来具体展示。如果你一定要量化这些数据，你可以查看第三方参照，它表明 Vue 2 相比 Angular2 是更快的。

在大小方面，虽然 Angular 2 使用 tree-shaking 和离线编译技术使代码体积减小了许多。但包含编译器和全部功能的 Vue2(23kb) 相比 Angular 2(50kb) 还是要小的多。但是要注意，用 Angular 2 的 App 的体积缩减是使用了 tree-shaking 移除了那些框架中没有用到的功能，但随着功能引入的不断增多，尺寸会变得越来越大。

#### 灵活性

Vue 相比于 Angular 2 则更加灵活，Vue 官方提供了构建工具来协助你构建项目，但它并不限制你去如何构建。有人可能喜欢用统一的方式来构建，也有很多开发者喜欢这种灵活自由的方式。

#### 学习曲线

开始使用 Vue，你使用的是熟悉的 HTML、符合 ES5 规则的 JavaScript（也就是纯 JavaScript）。有了这些基本的技能，你可以快速地掌握它(指南)并投入开发 。

Angular 2 的学习曲线是非常陡峭的。即使不包括 TypeScript，它的开始指南中所用的就有 ES2015 标准的 JavaScript，18个 NPM 依赖包，4 个文件和超过 3 千多字的介绍，这一切都是为了完成个 Hello World。而Vue’s Hello World就非常简单。甚至我们并不用花费一整个页面去介绍它。
- React中不同组件传递数据的方式有哪些？至少说出三种
>- 父组件向子组件传值 传参，props接收
>- 子组件向父组件传值 回调函数
>- 没有任何嵌套关系的组件之间传值<br>
(1) Event Emitter/Target/Dispatcher
特点：需要一个指定的订阅源
// to subscribe
otherObject.addEventListener(‘click’, function() { alert(‘click!’); });
// to dispatch
this.dispatchEvent(‘click’);<br>
(2) Publish / Subscribe
特点：触发事件的时候，你不需要指定一个特定的源，因为它是使用一个全局对象来处理事件（其实就是一个全局
广播的方式来处理事件）
// to subscribe
globalBroadcaster.subscribe(‘click’, function() { alert(‘click!’); });
// to dispatch
globalBroadcaster.publish(‘click’);<br>
(3) Signals
特点：与Event Emitter/Target/Dispatcher相似，但是你不要使用随机的字符串作为事件触发的引用。触发事件的每一个对象都需要一个确切的名字（就是类似硬编码类的去写事件名字），并且在触发的时候，也必须要指定确切的事件。（看例子吧，很好理解）
// to subscribe
otherObject.clicked.add(function() { alert(‘click’); });
// to dispatch
this.clicked.dispatch();

- 请描述React的组件加载生命周期函数以及`shouldComponentUpdate`方法的实际使用场景?
> 相关函数
简单地说，React Component通过其定义的几个函数来控制组件在生命周期的各个阶段的动作。

在ES6中，一个React组件是用一个class来表示的（具体可以参考官方文档），如下：

// 定义一个TodoList的React组件，通过继承React.Component来实现
class TodoList extends React.Component {
  ...
}
>这几个生命周期相关的函数有：

constructor(props, context)
>- 构造函数，在创建组件的时候调用一次。
void componentWillMount()
在组件挂载之前调用一次。如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次。

>- void componentDidMount()
在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs。

>- void componentWillReceiveProps(nextProps)
props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。

>- bool shouldComponentUpdate(nextProps, nextState)
组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。

>- void componentWillUpdate(nextProps, nextState)
shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。

>- void componentDidUpdate()
除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。
componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。

>- ReactElement render()
render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。记住，不要在render里面修改state。

>- void componentWillUnmount()
组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。

> 更新方式
在react中，触发render的有4条路径。

>- 以下假设shouldComponentUpdate都是按照默认返回true的方式。
首次渲染Initial Render
调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）
父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）
调用this.forceUpdate
下面是我对React组件四条更新路径地总结：
![Alt text](./react.png)
注意，如果在shouldComponentUpdate里面返回false可以提前退出更新路径。
## HTTP
- HTTP报文的组成部分
HTTP报文的组成部分：对报文进行描述的起始行、包含属性的头部块、可选的，包含数据的主体部分

1、起始行：所有的HTTP报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。

请求报文的起始行：该行包含了一个方法和一个请求的URL，还包含HTTP 的版本。

响应报文的起始行：该行包含了响应报文使用的HTTP版本、数字状态码、原因短语。

 

2、头部：HTTP首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/值对的列表。头部和协议配合工作，共同决定了客户端和服务器能做什么事情。

头部的分类：

通用头部：既可以出现在请求报文中，也可以出现在响应报文中，它提供了与报文相关的最基本的信息

Connection：允许客户端和服务器指定与请求/响应连接有关的选项

Date：提供日期和时间标志，说明报文是什么时间创建的

MIME-Version：给出了发送端使用的MIME版本

Trailer：如果报文采用了分块传输编码方式，就可以用这个首部列出位于报文拖挂部分的首部集合

Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式

Update：给出了发送端可能想要“升级”使用的新版本或协议

Via：显示了报文经过的中间节点(代理、网关)

Cache-Control：用于随报文传送缓存指示

 

请求头部：请求头部是只在请求报文中有意义的头部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力

Client-IP：提供了运行客户端的机器的IP地址

From：提供了客户端用户的E-mail地址

Host：给出了接收请求的服务器的主机名和端口号

Referer：提供了包含当前请求URI的文档的URL

UA-Color：提供了与客户端显示器的显示颜色有关的信息

UA-CPU：给出了客户端CPU的类型或制造商

UA-OS：给出了运行在客户端机器上的操作系统名称及版本

UA-Pixels：提供了客户端显示器的像素信息

User-Agent：将发起请求的应用程序名称告知服务器       

Accept：告诉服务器能够发送哪些媒体类型

Accept-Charset：告诉服务器能够发送哪些字符集

Accept-Encoding：告诉服务器能够发送哪些编码方式

Accept-Language：告诉服务器能够发送哪些语言

TE：告诉服务器可以使用那些扩展传输编码

Expect：允许客户端列出某请求所要求的服务器行为

Range：如果服务器支持范围请求，就请求资源的指定范围

If-Match：如果实体标记与文档当前的实体标记相匹配，就获取这份文档

If-Modified-Sinec：除非在某个指定的日期之后资源被修改过，否则就限制这个请求

If-None-Match：如果提供的实体标记与当前文档的实体标记不相符，就获取文档

If-Range：允许对文档的某个范围进行条件请求

If-Unmodified-Since：除非在某个指定日期之后资源没有被修改过，否则就限制这个请求

Authorization：包含了客户端提供给服务器，以便对其自身进行认证的数据

Cookie：客户端用它向服务器传送数据

Cookie2：用来说明请求端支持的cookie版本

Max-Forward：在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数

Proxy-Authorization：这个首部在与代理进行认证时使用的

Proxy-Connection：这个首部是在与代理建立连接时使用的

 

响应头部：响应头部为客户端提供了一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令

Age：(从最初创建开始)响应持续时间

Public：服务器为其资源支持的请求方法列表

Retry-After：如果资源不可用的话，在此日期或时间重试

Server：服务器应用程序软件的名称和版本

Title：对HTML文档来说，就是HTML文档的源端给出的标题

Warning：比原因短语更详细一些的警告报文

Accept-Ranges：对此资源来说，服务器可接受的范围类型

Vary：服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端

Proxy-Authenticate：来自代理的对客户端的质询列表

Set-Cookie：在客户端设置数据，以便服务器对客户端进行标识

Set-Cookie2：与Set-Cookie类似

WWW-Authenticate：来自服务器的对客户端的质询列表

 

实体首部：描述主体的长度和内容，或者资源自身

Allow：列出了可以对此实体执行的请求方法

Location：告知客户端实体实际上位于何处，用于将接收端定向到资源的位置(URL)上去

Content-Base：解析主体中的相对URL时使用的基础URL

Content-Encoding：对主体执行的任意编码方式

Content-Language：理解主体时最适宜使用的自然语言

Content-Length：主体的长度

Content-Location：资源实际所处的位置

Content-MD5：主体的MD5校验和

Content-Range：在整个资源中此实体表示的字节范围

Content-Type：这个主体的对象类型

ETag：与此实体相关的实体标记

Expires：实体不再有效，要从原始的源端再次获取实体的日期和时间

Last-Modified：这个实体最后一次被修改的日期和时间

 

扩展首部：规范中没有定义的新首部，开发者可以自定义一个首部的值/对

 

3、实体的主体部分：该部分其实就是HTTP要传输的内容，是可选的。HTTP报文可以承载很多类型的数字数据，比如，图片、视频、HTML文档电子邮件、软件应用程序等等。

 

HTTP方法：并不是每个服务器都实现了所有的方法。即使服务器实现了所有这些方法，这些方法的使用很可能也是受限的。例如，支持DELETE方法或PUT方法的服务器可能并不希望任何人都能够删除或存储资源，这些限制通常都是在服务器的配置中进行设置的。

常用的HTTP方法：

GET方法：通常用于请求服务器发送某个资源。不包含主体

HEAD方法：与GET方法类似，但服务器在响应中只返回首部，使用HEAD方法可以，在不获取资源的情况下了解资源的情况(比如，判断其类型)；通过查看响应中的状态码，看看某个对象是否存在；通过查看首部，测试资源是否被修改了；不包含主体

POST方法：该方法是用来向服务器发送数据的，常用于HTML表单，包含主体

PUT方法：该方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，如果那个URL已经存在的话，就用这个主体来替代它。包含主体

TRACE方法：主要用于验证请求是否如愿穿过了请求/响应链，不包含主体

OPTIONS方法：决定可以在服务器上执行那些方法，不包含主体

DELETE方法：该方法就是请服务器删除请求URL所指定的资源，但是客户端应用程序无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求，不包含主体

扩展方法：指的是没有在HTTP/1.1规范中定义的方法，这些方法为开发者提供了一种扩展这些HTTP服务能力的手段。

 

状态码：HTTP状态码被分成了五大类。状态码为客户端提供了一种理解事务处理结果的便捷方式。

1、100~199(信息性状态码)：HTTP/1.1向协议中引入了信息性状态码

2、200~299(成功状态码)：客户端发起请求时，这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求

3、300~399(重定向状态码)：重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容

4、400~499(客户端错误状态码)：有时客户端会发送一些服务器无法处理的东西。浏览网页时，我们都看到过臭名昭著的404 Not Found错误码，这只是服务器在告诉我们，它对我们请求的资源一无所知

5、500~599(服务器错误状态码)：有时客户端发送了一条有效请求，服务器自身却出错了，这些会返回5xx状态码
- GET和POST的区别
- HTTP常见状态码
状态码：HTTP状态码被分成了五大类。状态码为客户端提供了一种理解事务处理结果的便捷方式。

1、100~199(信息性状态码)：HTTP/1.1向协议中引入了信息性状态码

2、200~299(成功状态码)：客户端发起请求时，这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求

3、300~399(重定向状态码)：重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容

4、400~499(客户端错误状态码)：有时客户端会发送一些服务器无法处理的东西。浏览网页时，我们都看到过臭名昭著的404 Not Found错误码，这只是服务器在告诉我们，它对我们请求的资源一无所知

5、500~599(服务器错误状态码)：有时客户端发送了一条有效请求，服务器自身却出错了，这些会返回5xx状态码

- 什么是Restful API?
> 网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备......）。
  因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现"API First"的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。
- HTTPS和HTTP的区别是什么?
http和https的区别
>- 1. HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
>- 2. HTTP 是不安全的，而 HTTPS 是安全的
>- 3. HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
>- 4. 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层
>- 5. HTTP 无法加密，而HTTPS 对传输的数据进行加密
>- 6. HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书
>- 申请SSL证书部署到服务器端就可以实现网站https加密访问！
- 从在浏览器中输入URL到页面渲染出来都经过了什么过程？
>- 输入地址
>- 浏览器查找域名的 IP 地址.这一步包括 DNS 具体的查找过程，包括：浏览器缓存->系统缓存->路由器缓存...
>- 浏览器向 web 服务器发送一个 HTTP 请求
>- 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）
>- 浏览器跟踪重定向地址
>- 服务器处理请求
>- 服务器返回一个 HTTP 响应
>- 浏览器显示 HTML
>- 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
>- 浏览器发送异步请求
- JSON和JSONP 区别是什么？JSONP的原理是？
> json返回的是一串数据,是一个对象，是一种特殊的数据格式；而jsonp返回的是脚本代码（包含一个函数调用）；
是一种跨域方法。

> 就是利用<script>标签没有跨域限制的“漏洞”（历史遗迹啊）来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个<script>元素，地址指向第三方的API网址，形如：     <script src="http://www.example.net/api?param1=1&param2=2"></script>     并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。     第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：     callback({"name":"hax","gender":"Male"})     这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。
  
- 用过那些跨域技术
jsonp
- ajax的参数
````
$.ajax({  
  
        type: 'GET',    // 这是请求的方式 可以是GET方式也可以是POST方式, 默认是GET  
  
        url: ' xxx.php ',   // 这是请求的连接地址 一般情况下这个地址是后台给前端的一个连接，直接写就可以  
  
        dataType: 'json',  // 这是后台返回的数据类型 一般情况下都是一个json数据， 前端遍历一下就OK  
  
        async: true, // 默认为true，默认为true时，所有请求均为异步请求，如果需要发送同步请求，需设置为false,  
  
        timeout: 8000, // 设置请求超时时间（毫秒）。此设置将覆盖全局设置  
  
        data: {  
                // 要传递的参数  
  
                'xxx' : 'xxx',  
                  
                ... ...   
        },  
  
        beforeSend: function () {  
  
                // 在发送请求前就开始执行 （一般用来显示loading图）  
  
        }，  
  
        success: function (data) {  
  
                // 发送请求成功后开始执行，data是请求成功后，返回的数据  
  
        },  
  
        complete: function () {  
  
                //当请求完成后开始执行，无论成功或是失败都会执行 （一般用来隐藏loading图）  
          
        }，  
  
        error: function (xhr, textStatus, errorThrown) {  
  
                //  请求失败后就开始执行，请求超时后，在这里执行请求超时后要执行的函数  
  
        }  
}).done(function () {  
          
        // 这个函数是在ajax数据加载完之后，对数据进行的判断，在涉及到对ajax数据进行操作无效时，在这个函数里面写是可以起到效果的  
  
})  
````

## 前后端通信
- 什么是同源策略及限制?
>同domain（或ip）,同端口，同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。这种安全限制称为同源策略。
- 前后端如何通信?
>web服务器（apache、tomcat等），网络协议（http、socket等），浏览器（chrome、FF、IE等）。浏览器发起建立连接请求，通过网络协议与服务器建立连接，服务器保持连接，获取浏览器想要的数据，服务器通过连接返回内容给浏览器，浏览器把数据呈现出来。
 
- 用原生JS模拟一下`jquery`的`ajax`方法
````
~(function () {
    // 对象合并
    Object.objAssign = function (tar, source) {
        for (let k in source) {
            if (source.hasOwnProperty(k)) {
                tar[k] = source[k];
            }
        }
    };

    // 创建ajax实例
    function getXhr() {
        let arrFn = [function () {
            return new XMLHttpRequest();
        }, function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }];
        let curFn = null, xhr = null;
        for (let i = 0; i < arrFn.length; i++) {
            curFn = arrFn[i];
            try {
                xhr = curFn();
                getXhr = curFn;
                break;
            } catch (e) {
            }
        }
        if (!xhr) {
            throw new Error('版本太低，请升级浏览器~');
        }
        return xhr;
    }

    /**
     *
     * @param options  参数对象
     */
    function ajax(options) {
        let _options = { // 默认参数对象
            url: null,
            type: 'GET',
            cache: true,
            context: null,
            async: true,
            data: null,
            dataType: 'text',
            success: null,
            timeout: null,
            error: null
        };
        // 将传递进来options 和默认_options 进行合并
        Object.objAssign(_options, options);

        if (!_options.url) {
            console.warn('缺少url');
            return;
        }

        // 如果url有问号 直接去掉
        if (_options.url.indexOf('?') > -1) {
            _options.url = _options.url.slice(0, -1);
        }

        // GET 方式中 需要单独处理 cache缓存问题  data 发送给后台的数据
        let flag = false;
        if (_options.type.toUpperCase() === 'GET') {
            if (!_options.cache) { // 不需要缓存时 拼接时间戳
                _options.url += '?_=' + Date.now();
                console.log(_options.url);
                flag = true;
            }
            // url?_=123123
            // url ?id=25   
            // 拼接查询参数query
            for (let k in _options.data) {
                if (_options.data.hasOwnProperty(k)) {
                    if (flag) { // 有？不需要再拼接 直接开头拼接&
                        _options.url += '&' + k + '=' + _options.data[k];
                    } else {
                        _options.url += '?' + k + '=' + _options.data[k];
                        flag = true;
                    }
                }
            }
        }

        // 创建ajax实例
        let xhr = getXhr();
        let {url, type, async, data, dataType, timeout, error, success, context} = _options;
        context || (context = _options); // 回调函数中上下文处理
        xhr.open(type, url, async);
        xhr.responseType = dataType;
        xhr.timeout = timeout;
        xhr.onerror = xhr.ontimeout = error;
        xhr.onreadystatechange = function () {
            if (this.readyState === 4 && /^2\d{2}$/.test(this.status)) {
                typeof success === 'function' ? success.call(context, this.response) : null;
            }
        };
        xhr.send(JSON.stringify(data));
    }

    window.$$ = {ajax};
})();

````
- 跨域通信的几种方式?

>- 修改document.domain

document.domain 用来获取当前网页的域名，document.domain可以被赋值

document.domain只能修改成当前域名的主域名或者基础域名，如当前域名是b.360.cn，那么document.domain只能改成主域名www.360.cn或者基础域名360.cn，改为其它值会提示“参数无效”

如 a.360.cn/x.html 和 b.360.cn/y.html 都将document.domain 改为360.cn 后，两个页面就可以跨域通信了

前提条件：两个域名必须属于同一个基础域名且协议端口一致

隐患：当a.360.cn 遭到攻击后，b.360.cn会有安全隐患

>- 动态创建script

script 不受同源策略限制，在a.360.cn页面中引入b.360.cn的js文件，就可以操作a.360.cn下的cookie、DOM等

>- 通过location.hash传参

a、b、c三个页面，a、c页面同源，b是需要跨域的页面，a页面创建一个iframe指向b页面，b页面根据parent.location.hash 的值去做相应的操作，操作完成后修改parent.location.hash 的值告诉a，a监听自己的hash变化，IE、chrome下，b页面无法直接修改parent.location.hash，需要借助与a同源的c页面，具体做法是，b页面创建iframe指向c页面，b页面改变自己的hash，c页面读取b页面的parent.location.hash去修改a页面的hash，a、c页面同源，c页面可以修改a页面的hash，即parent.parent.location.hash

通过window.name传参

a、b、c三个页面，a、c页面同源，b是需要跨域的页面，a页面创建iframe指向b页面，b页面将数据赋值给window.name，接着修改iframe的src指向c页面，a、c页面同源，参考document.domain方法取得c页面window.name的值，为了安全，获取数据后销毁iframe

>- JSONP

动态创建script标签加载数据，前端将回调函数名传给服务端，服务端返回回调函数，函数参数是请求过来的数据，将返回值插入页面会自动执行

1）安全问题

2）要确定jsonp请求是否成功并不容易

## 安全
- `CSRF`的原理以及如何防御
>- CSRF原理
我们理解了session的工作机制后，CSRF也就很容易理解了。CSRF攻击就相当于恶意用户A复制了sessionid(就像房卡一样)。别人那你的sessionid进入你网站的会员中心，享受你能享受的服务
![Alt text](./csrf.jpg)

>- CSRF防御

> 1.通过 referer、token 或者 验证码 来检测用户提交。

> 2.尽量不要在页面的链接中暴露用户隐私信息。

> 3.对于用户修改删除等操作最好都使用post 操作 。

> 4.避免全站通用的cookie，严格设置cookie的域。
- `XSS`的原理和如何防御
>- XSS原理及防范
Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个
看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，
当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。

>- XSS防范方法

> 1.代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。

> 2.避免直接在cookie 中泄露用户隐私，例如email、密码等等。

> 3.通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。

> 4.尽量采用POST 而非GET 提交表单

## 渲染机制
#### 1.什么是`DOCTYPE`及作用?标准模式和兼容模式有什么区别?
 DOCTYPE是document type(文档类型)的简写,用来告诉浏览器的解析器使用哪种HTML或XHTML规范解析页面。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
 Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（兼容）模式（也就是松散呈现模式或者怪异模式）用于呈现为传统浏览器而设计的网页。
###### 区别 
 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。
 兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。简单说就是尽可能的显示能显示的东西给用户看。

具体区别：

 1.盒模型
 
   在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width;
   
   在兼容模式中 ：width则是=width+padding+border
 
 2.兼容模式下可设置百分比的高度和行内元素的高宽
 
   在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
   在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。
 
 3.用margin:0 auto设置水平居中在IE下会失效
 
   使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
   body{text-align:center};#content{text-align:left}
 
 4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效
#### 2.浏览器是如何渲染页面的?
> WEB 页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验简单地说，页面渲染就是浏览器将 HTML 代码根据 CSS 定义的规则显示在浏览器窗口中的这个过程。
#### 3.什么是重排？什么时候会触发重排?
> 重排是更明显的一种改变，可以理解为渲染树需要重新计算。下面是常见的触发重排的操作：
- DOM元素的几何属性变化
- DOM树的结构变化(当DOM树的结构变化时，例如节点的增减、移动等，也会触发重排。)
- 获取某些属性
#### 4.什么是重绘？什么时候会触发重绘?
> 　重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，并不一定伴随重排。

## JS运行机制
- 如何理解JS的单线程
> JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列。所以当多个事件触发时，会依次放入队列，然后一个一个响应。
  
- 什么是`Event Loop`,请简述其过程
> Event Loop是一个程序结构，用于等待和发送消息和事件。
简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。
![Alt text](./loop.jpg)

> 上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。

> 可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为”异步模式“（asynchronous I/O）或”非堵塞模式”（non-blocking mode）。
## 服务器
- 如何在web应用中在实现权限控制?
- Web服务器、应用服务器、Web容器、反向代理服务器的区别和联系?

## 错误处理
- 前端错误的分类?
1. SyntaxError：语法错误
2. Uncaught ReferenceError：引用错误
3. RangeError：范围错误
> RangeError是当一个只超出有效范围时发生的错误。主要的有几种情况，第一是数组长度为负数，第二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。
引用一个不存在的变量时发生的错误。将一个值分配给无法分配的对象，比如对函数的运行结果或者函数赋值。
4. TypeError类型错误
> 变量或参数不是预期类型时发生的错误。比如使用new字符串、布尔值等原始类型和调用对象不存在的方法就会抛出这种错误，因为new命令的参数应该是一个构造函数。
5. URIError，URL错误;主要是相关函数的参数不正确。
6. EvalError eval()函数执行错误
- 程序出现bug了，你是如何调试的?
> 在浏览器控制台给运行中的代码加断点或者在代码中console.log()
- 如何分类捕获不同的错误?
> try{}catch(e){}
- 如何把生产环境的错误上报？
> 使用bug管理系统'禅道'

## 页面性能
- 前端性能优化的方法有哪些？至少说出10种以上

>- 规则01：尽量减少HTTP请求前端优化的黄金准则指导着前端页面的优化策略：只有10%-20%的最终用户响应时间花在接受请求的HTML文档上，剩下的80%-90%时间花在为HTML文档所引用的所有组件（图片、脚本、样式表等）进行的HTTP请求上。因此，改善响应时间的最简单途径就是减少组件的数量，并由此减少HTTP请求的数量。当然很多人就会说，既然这样，那我们就减少页面组件的数量不就OK了吗？那你试试，你会掀起一场性能优化和产品设计之间的大PK。所以，我们要减少HTTP请求是要平衡性能和设计的。如果找到这个平衡点呢？书中从以下几个方面做了介绍，我逐一说明：①  图片地图初看“图片地图”四个字，对非专业的前端人员来说一头雾水，我的第一印象就是这样的，咱们以京东的移动站点为例，右侧用户和购物车的图标，正常实现我会选择如下方式：<a href=”用户跳转页面URL”>  <div class=”定义用户icon显示的样式表”></div></a><a href=”购物车跳转页面URL”>  <div class=” 定义用户icon显示的样式表”></div></a>这种方式无可厚非的，但是两张图片就有两个HTTP请求，这明显是增加了页面中的HTTP请求。那么我们可以把这两个HTTP请求变成一个吗？答案当然是可以的，这就是图片地图：允许在一张图片上关联多个URL，而目标URL的选择取决于用户单击了图片上的哪个位置。这样上面京东两个图标合并成一张图片，这样图片的HTTP请求就减少了一个。示例代码如下：<img src=合并后的图片><map name=”map1”>  <areashape=”rect” coords=”0,0,40,40” href=”用户跳转页面URL”>  <areashape=”rect” coords=”50,0,90,40” href=”购物车跳转页面URL”></map>不过图片地图只支持矩形形状，其他形状不支持。②  请CSS喝“雪碧”（CSS Sprites）CSS Sprites一句话：将多个图片合并到一张单独的图片，这样就大大减少了页面中图片的HTTP请求。③  内联图片和脚本使用data:URL（Base64编码）模式直接将图片包含在Web页面中而无需进行HTTP请求。但是此种方法存在明显缺陷：- 不受IE的欢迎；- 图片太大不宜采用这种方式，因为Base64编码之后会增加图片大小，这样页面整体的下载量会变大；- 内联图片在页面跳转的时候不会被缓存。（大图片可以使用浏览器的本地缓存，在首次访问的时候保存到浏览器缓存中，典型的是HTML5的manifest缓存机制以及LocalStorage等）。④  样式表的合并将页面样式定义、脚本、页面本身代码严格区分开，但是样式表、脚本也不是分割越细越好，因为没多引用一个样式表就增加一次HTPP请求，能合并的样式表尽量合并。一个网站有一个公用样式表定义，每个页面只要有一个样式表就OK啦。通过以上四个努力之后，你会发现你的网页响应时间最多能减少一半，这不是作者说大话，也不是我狂吹，我亲手用我的移动网站首页做了一个尝试，本地测试之后响应时间能减少40%左右。所以减少页面HTTP请求数量，是一个很重要的原则。遵循此原则可以同时改善首次访问和后续访问的响应时间，而每一个网站的首次响应时间会决定用户之后还来不来的重要原因。
>- 规则02：使用内容发布网络（CDN的使用）什么叫内容发布网络（CDN）？它是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。主要用于发布页面静态资源：图片、css文件、js文件等。如此，能轻易地提高响应速度。关于CDN的具体详细原理以及优缺点，各位可以自行询问度娘或者google。
>- 规则03：添加Expires头浏览器使用缓存来减少HTTP请求的数据，并减小HTTP响应的大小，使页面加载更快。Web服务器使用Expires头来告诉浏览器它可以使用一个组件的当前副本，直到指定的deadline为止。HTTP规范中称此头为：在这一时间之后响应被认为失效。个人对这块表示不想使用，其实就是一句话，把一些css、js、图片在首次访问的时候全部缓存到浏览器本地，从我做移动网站的过程中发现，其实没有这么复杂，完全可以使用HTML5提供的本地缓存机制就OK了。关于HTML5本地缓存机制，各位可以查阅相关资料。后续我也会对HTML5的缓存机制进行介绍的。
>- 规则04：压缩组件（使用Gzip方式）书中关于压缩从gzip压缩方式到如何压缩讲了很多，我想直接跳过，对于做PC网站或者移动网站来说，急需要压缩的是css文件和js文件，至于如何压缩，网上有很多在线工具，去挑选一个自己用的顺手看的顺眼的就好，当然也有人选择对HTML进行压缩，这样也可以。但是实际工作中我没有这么做。之所谓没有这么做，是因为我觉得很麻烦。不要鄙视我，毕竟我不是一个真正意义上的前端工程师，哈哈！
>- 规则05：将CSS样式表放在顶部如果将css样式定义放在页面中或者页面底部，会出现短暂白屏或者某一区域短暂白板的情况，这和浏览器的运营机制有关的，不管页面如何加载，页面都是逐步呈现的。所以在每做一个页面的时候，用Link标签把每一个样式表定义放在head中。
>- 规则06：将javascript脚本放在底部浏览器在加载css文件时，页面逐步呈现会被阻止，直到所有css文件加载完毕，所以要把css文件的引用放到head中去，这样在加载css文件时不会组织页面的呈现。但是对于js文件，在使用的时候，它下面所有也页面内容的呈现都会被阻塞，将脚本放在页面越靠下的地方，就意味着越多的内容能够逐步呈现。
>- 规则07：避免使用CSS表达式CSS表达式是动态玩CSS的一种很强大的方式，但是强大的同时也存在很高的危险性。因为css表达式的频繁求值会导致css表达式性能低下。如果真想玩css表达式，可以选用只求值一次的表达式或者使用事件处理来改变css的值。
>- 规则08：使用外部javascript和CSS内联js和css其实比外部文件有更快的响应速度，那为什么还要用外部呢？因为使用外部的js和css可以让浏览器缓存他们，这样不仅HTML文档大小减少，而且不会增加HTTP请求数量。另外，使用外部js和css可以提高组件的可复用性。
>- 规则09：减少DNS查询DNS查询有时间开销，通常一个浏览器查找一个给定主机名的IP地址需要20-120ms。缓存DNS：缓存DNS查询可以很好地提高网页性能，一旦缓存了DNS查询，之后对于相同主机名的请求就无需进行再次的DNS查找，至少短时间内不需要。所以在使用页面中URL、图片、js文件、css文件等时，不要使用过多不同的主机名。
>- 规则10：精简javascript如何精简？其实W3Cfuns已经给大家准备好精简JS所需的所有工具“前端神器”，这点W3Cfuns为大家做的很不错，在这个规则里我们就用到“JS压缩/混淆/美化工具”最初始的精简方式：就是移除不必要的字符减小js文件大小，改善加载时间。包括所有的注释、不必要的空白字符。高级一点的精简方式就是：混淆。它不但会移除不必要的字符，还会改写代码，比如函数和变量的名字会被改成很短的字符串，这样使js代码更简练更难阅读。但是我一般很少使用混淆，一个现在互联网时代，代码没有必要整的那么神秘，大可以大家一起share，天下代码一起抄，只要抄出自己的特色就ok了。而且一旦使用混淆，对于js代码的维护和调试都很复杂，因为有时候混淆之后的js代码完全看不懂。其实实际开发过程中，从文件大小和代码可复用性来说，不仅仅是js代码需要精简，css代码一样也很需要精简。
>- 规则11：避免重定向重定向的英文是Redirect，用于将用户从一个URL重新跳转到另一个URL。最常见的Redirect就是301和302两种。关于重定向的性能影响这里就不说了，自行查阅相关资料吧。在我们实际开发中避免重定向最简单也最容易被忽视的一个问题就是，设置URL的时候，最后的“/”，有些人有时候会忽略，其实你少了“/”，这时候的URL就被重定向了，所以在给页面链接加URL的时候切记最后的“/”不可丢。
>- 规则12：删除重复脚本重复的js代码除了有不必要的HTTP请求之外，还会浪费执行js的时间。将你使用的js代码模块化，可以很好地避免这个问题，至于js模块化如何实现，现在有很多可以使用的开源框架，我用的比较多的是我们公司玉伯的Sea.js。
>- 规则13：配置ETagEtag（Entity Tag），实体标签，是Web服务器和浏览器用户确认缓存组件的有效性的一种机制。写的很复杂，对我这种非专业的前端开发人员来说，有点过了，关于这个原则有兴趣的自己看吧。
>- 规则14：使Ajax可缓存针对页面中主动的Ajax请求返回的数据要缓存到本地，当然这个是针对短期内不会变化的数据。如果不确定数据变化周期的话，可以增加一个修改标识的判断，我正常处理过程中会给一些Ajax请求返回的数据增加一个MD5值的判断，每次请求会判断当前MD5是否变化，如果变化了取最新的数据，如果不变化，则不变。

- 如何实现JS的异步加载? `async`和`defer`的区别是什么?
>- (1) defer，只支持IE 
   defer属性的定义和用法（我摘自w3school网站） 
   defer 属性规定是否对脚本执行进行延迟，直到页面加载为止。 
   有的 javascript 脚本 document.write 方法来创建当前的文档内容，其他脚本就不一定是了。 
>- (2) async： 
   async的定义和用法(是HTML5的属性) 
   async 属性规定一旦脚本可用，则会异步执行。 
>- 可以使用回掉函数callBack
## 缓存
- Expires和Cache-Control是如何工作的？
> Cache-control用于控制HTTP缓存（在HTTP/1.0中可能部分没实现，仅仅实现了Pragma: no-cache）

> Expires 表示存在时间，允许客户端在这个时间之前不去检查（发请求），等同max-age的
  效果。但是如果同时存在，则被Cache-Control的max-age覆盖。
- Last-Modified和Etag是如何工作的？
Last-Modified和Etags如何帮助提高性能?
> 聪明的开发者会把Last-Modified 和ETags请求的http报头一起使用，这样可利用客户端（例如浏览器）的缓存。因为服务器首先产生 Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。

> 过程如下:
  >- 1,客户端请求一个页面（A）。
  
  >-2,服务器返回页面A，并在给A加上一个Last-Modified/ETag。
  
  >-3,客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。
  
  >-4,客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。
  
  >-5,服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。
- 请描述`cookie`、`sessionStorage`和`localStorage`的区别
> sessionStorage 和 localStorage(又称为DOM Storage) 是HTML5 WebStorage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。

> 共同点：都是保存在浏览器端，且同源的。

> 区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
 
> cookies
>- 域+path+name 标识

>- name+value, 有服务器产生，发回client，保存在client (http 的set-cookies 字段)

>- 每次http请求都会发送 Cookies中 “域+path”相同的所有cookie

>- 多数浏览器Cookie最大问为4K

>- 浏览器可能还限制了用户计算机存储的cookie数量（如允许每个站点最多存储20个cookies，超过则删除旧的；有些浏览器还对所有站点的cookie总数作出限制，如300）

> Local Storage

>- 域相关
>- 永久保存在本地(client)
>- 容量无限制
>- 数据不会过期，除非由于security 原因活着用户请求删除
 
> Session Storage

>- 跟Local Storage类似，但Session Storage 只与当前会话相关，浏览器关闭则删除。 其特别之处有：
>- top browser context，及在同一个页面内的所有frame/iframe 共享同一个session storage； 不同的page 有不同的session storage
>- 会话结束即删除
# 项目问题
- 介绍一下你的项目？这个项目有哪些模块？你负责哪些模块？
- 你在项目中的角色
- 你觉得在项目中做的最出彩的点有哪些？
- 遇到过哪些非常难以解决的问题？最终是如何解决的？
- 如果你是项目负责人，你会如何分配任务？如何保证按时完成？如何让成员够持续成长？

# 正常非技术问题
- 请你自我介绍一下你自己？
- 你觉得你个性上最大的优点是什么？
- 说说你最大的缺点？
- 你对加班的看法？
- 在五年的时间内，你的职业规划？
- 你朋友对你的评价？
- 你还有什么问题要问我的吗？
- 你的业余爱好是什么？
- 你为什么从上家公司离职?

# 故意挖坑的问题
- 你的直属上级和顶级上级对一件事情的意见不一致，你会听谁的意见？
- 如果部门开发的时候和你的主管发生了争吵，你会如何处理？
- 与上级意见不一致，你将怎么办？
- 你喜欢跟什么样的主管共事？
- 我们为什么要聘用你?
- 你没有工作经验如何能胜任这份工作？
- 你最崇拜的人是谁?
- 你有创业的想法吗？

## 代码运行结果，并解释
```javascript
if(!("a" in window)){
  var a = 1;
}
console.log(a);
```
> if语句中，无论条件是否成立，都会对里面的变量进行声明，且只声明不定义
```javascript
function MyObj(){
  this.p.pid++;
}
MyObj.prototype.p = {'pid':0}
MyObj.prototype.getNum = function(num){
  return this.p.pid+num;
}
var _obj1 = new MyObj();//实例化一个对象并执行myObj函数并修改了实例原型对象p的值
var _obj2 = new MyObj();
console.log(_obj1.getNum(1)+_obj2.getNum(2))
```
> 实例化一个_obj1对象并执行MyObj函数并修改了实例原型对象p的值为1
实例化一个_obj2对象并执行MyObj函数并修改了实例原型对象p的值为2
最后结果是2+1+2+2=7
```javascript
var func = (function(a){
  this.a = a;
  return function(a){
    a+=this.a;
    return a;
  }
})(function(a,b){
  return a;
}(1,2));
func(4);
```
> 1.自执行过程
这个自执行函数实参是后面括号内部自执行函数的返回结果
````
function(a,b){
    return a;
}(1,2)
````
> 即结果是1传入到func中，
自执行func过程中
this.a中的this指向window，全局a为3
然后返回一个匿名函数作为func的函数体

> 2.func(4)调用过程
func(4)是给返回的那个匿名函数传实参，此时this还是window
a=1+4,结果是5


```javascript
function Foo() {
 getName = function () { alert (1); };
 return this;
}
Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
var getName = function () { alert (4);};
function getName() { alert (5);}

//请写出以下输出结果：
Foo.getName();//2
getName();//4，预解释getName只声明
Foo().getName();//将全局中getName重新定义,window.getname()//1
getName();//1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3,Foo.getName {}
```


```javascript
for(var i=0;i<10;i++){
       alert(i);
       break;
   }
   alert(i);
    //1
   for(var i=0;i<10;i++){
      continue;
      alert(i);
   }
   alert(i)
   //10
```
> break终止循环，continue终止本次循环，继续下次循环
```javascript
function C1(name){
	if(name) this.name = name;
}
function C2(name){
    this.name =name;
}
function C3(name){
    this.name = name ||'join';
}
C1.prototype.name='Tom';
C2.prototype.name='Tom';
C3.prototype.name='Tom';
alert(new C1().name)+(new C2().name)+(new C3().name);
// Tom
// 未传name进去name为undefined，结果也是undefined
// join

```

```javascript
var a=1;
Var obj ={
   “name”:”tom”
}
function fn(){
   var a2 = a,//1
   obj2 = obj,
   a2 =a,//1
   obj2.name =”jack”//
}
fn();
console.log(a);
//1
console.log(obj);
//Object {name: "jack"}
```

每个人必须建立自己的github地址将答案，放到github上，并且将答案抄在纸上（加深记忆 防止粘贴），晚上之前必须`每个人`都交上来，大家不许互相讨论，可以采用google和百度等手段，
目的：校验自己的不足查缺补漏，学会自我查找问题，提升解决问题的能力。
